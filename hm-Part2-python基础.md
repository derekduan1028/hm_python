[toc]



# **Part2 python基础**

**lesson 131-Python简介**

## 认识Python

>*人生苦短，我用Python ---- Life is short , you need Python*

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201019103902279.png" align="left" alt="image-20201019103902279" style="zoom:80%;" />



**目标**
	* python的起源
		解释器为c语言实现，可直接调用c库文件
	* 为什么用python
	* 特点
	* 优缺点

### 01.Python的起源

> *Python 的创始人为吉多•范罗苏姆（Guido van Rossum）*

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201019104445396.png" align="left" alt="image-20201019104445396" style="zoom:100%;" />

（略）

#### 1.1 解释器（科普）

**计算机不能直接理解任何除机器语言以外的语言，**所以必须把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**

编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同。当编译器以解释方式运行的时候，** 也称为**解释器**

![image-20201019104755800](/Users/derek/Library/Application Support/typora-user-images/image-20201019104755800.png)

#### 1.2 Python的设计目标

1999年，吉多.范罗苏姆向DARPA 提交了一条名为"Computer Programming for Everybody"的资金申请，并在后来说明了他对Python的目标：

* 一门**简单直观的语言**并与主要竞争者一样强大
* **开源**，以使任何人都可以为它做贡献
* 代码**像纯英语那样容易理解**
* 适用于**短期**开发的日常任务

这些想法中的基本都已经成为现实，Python已经横位一门流行的编程语言

#### 1.3 Python 的设计哲学

1. 优雅
2. 明确
3. 简单

* Python 开发者的哲学：**用一种方法，最好是只有一种方法来做一件事**
* 如果面临多种选择，Python开发者一般会拒绝花俏的语法，而选择 **明确没有或者很少有歧义的语法**

> ***在python社区，吉多被称为“仁慈的独裁者”***

### 02. 为什么选择 Python

* 代码量少
* ........

> ***同一个问题，用不同的语言解决，代码量差距还是很多的，一般情况下，`Python`是`Java`的1/5，所以说 人生苦短，我用Python***

### 03. Python 特点

* Python 是完全面向对象的语言
  * **函数、模块、数字、字符串 都是对象，** **在Python中一切皆对象**
  * 完全支持继承、重载、多重继承
  * 支持重载运算符，也支持泛型设计
* Python **拥有一个强大的标准库**，Python语言的核心只包含 **数字、字符串、列表、字典、文件** 等常见类型和函数，而由Python 标准库提供了 **系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理** 等额外的功能
* Python 社区提供了 **大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算、人工智能、机器学习、web开发、数据库接口、图形系统** 多个领域

**面向对象的思维方式**

* **面向对象** 是一种 **思维方式** ，也是一门 **程序设计技术**
* 要解决一个问题前，首先考虑 **由谁** 来做，怎么做事情 是 谁 的职责，最后把事情做好就行
  * **对象** 就是 **谁**
* 要解决复杂的问题，就可以找**多个不同的对象，各司其职**，共同实现，最终完成需求

### 04. Python的优缺点

#### 4.1 优点

* 简单、易学
* 免费、开源
* **面向对象**
* 丰富的库
* 可扩展性
  * 如果需要一段关键代码运行的更快或者希望某些算法不公开，可以把这部分程序用`C`或`C++`编写，然后在`Pyton`中使用它们
* ........

#### 4.2 缺点

* 运行速度
* 国内市场小
* 中文资料匮乏



**lesson 132 第一个程序**

## 第一个Python程序

**目标**

* 第一个`HelloPython`程序
* `Python 2.x`与`Python 3.x`版本简介
* 执行 `Python`程序的三种方式
  * 解释器 —— `python` / `python3`
  * 交互式 —— `ipython`
  * 集成开发环境 —— `PyCharm`

### 0.1 第一个HelloPython程序

#### 1.1 Python源程序的基本概念

1. Python 源程序就是一个 **特殊格式的文本文件** ，可以 **使用任意文本编辑软件** 做 `Python`的开发
2. Python 程序的 **文件扩展名** 通常是 `.py`

#### 1.2 演练步骤

* 在桌面下，新建`认识Python`目录
* 在`认识Python`目录下新建 `01-HelloPython.py`文件
* 使用 **gedit** 编辑 `01-HelloPython.py`并且输入以下内容：

```python
print("hello python")
print("hello world")
```

* 在终端中输入以下命令执行`01-HelloPython.py`

```python
$ python 01-HelloPython.py
```

> *`print`是`python`中我们学习的第一个 **函数***
>
> *`print` 函数的作用，可以把“”内部的内容，输出到屏幕上*

#### 1.3 演练扩展——认识错误(BUG)

**关于错误**

* 编写的程序 **不能正常执行**，或者 **执行的结果不是我们期望的**
* 俗称`BUG`, 是程序员在开发时非常常见的，初学者常见错误的原因包括：
  1. 手误
  2. 对已经学习过的知识理解存在不足
  3. 对语言还有需要学习和提升的内容
* 在学习语言时，不仅要 **学会语言的语法**，而且还要 **学会如何认识错误和解决错误的方法**

> *每一个程序员都是在不断地修改错误中成长的*

**第一个演练中的常见错误**

* 1> **手误**，例如使用 `pirnt("hello world")`

```python
NameError: name 'pirnt' is not defined
```

* 2> 将多条`print`写在一起

```python
SyntaxError: invalid syntax
语法错误：语法无效
```

> ***每一行代码负责完成一个动作***

* 3> 缩进错误

```python
IndentationError: unexpected indent
缩进错误：不期望出现的缩进
```

> * ***Python 是一个格式非常严格的程序设计语言***
> * ***目前而言，大家记住每行代码前面都不要增加空格***

* 4> **python 2.x** **默认不支持中文**

目前市场上有两个Python 的版本并存，分别是 2.x 和 3.x

* Python 2.x 默认不支持中文，原因为 字符编码 问题
* Python 2.x 的解释器名称是python
* Python 3.x 的解释器名称是python3

```python
SyntaxError: Non-ASCII character '\xe4' in file tmp1.py on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details

语法错误：在tmp1.py中 第3行出现了非ASCII 字符'\xe4'，但是没有声明文件编码
请访问 http://python.org/dev/peps/pep-0263/ for details 了解信息
```

> * ASCII 字符只包含256个字符，不支持中文
> * 有关字符编码，后续会讲

### 02. Python 2.x 与 3.x 版本简介

目前市场上有两个Python 的版本并存，分别是`Python 2.x`和 `Python 3.x`

> ***新的Python 程序建议使用`Python 3.x`版本语法***

* Python 2.x 是 **过去的版本**
  * 解释器名称是python
* Python 3.x 是 **现在和未来的主流版本**
  * 解释器名称是**python3**
  * 相对于早期版本，这是一个 **较大的升级**
  * 为了不带入过多的累赘，3.x在设计时，**没有考虑向下兼容**
    * 许多早期版本设计的程序都无法在 3.x上正常执行
  * Python 3.0发布于 **2008年**
  * 到目前为止，3.x已经有多个稳定版本
    * 3.3发布于2012
    * 3.4发布于2014
    * 3.5发布于2015
    * 3.6发布于2016
* 为了照顾现有程序，官方提供了一个过渡版本——**Python 2.6**
  * 基本使用了2.x的语法和库
  * 同时考虑了向 3.x的前一，**允许使用部分 3.0**的语法和函数
  * 2010年中推出的2.7被确定为 **最后一个2.x版本**

> *提示：如果开发时，无法立即使用Python 3.0（还有极少的第三方库不支持3.0的语法），建议*
>
> * ***先使用3.0版本进行开发***
> * ***然后使用 2.6、2.7版本来执行，并且做一些兼容性的处理***



**lesson 133 执行Python的方式**

### 03. 执行Python程序的三种方式

#### 3.1 解释器python/python3

**Python 的解释器**

```python
# 使用python 2.x的解释器
$ python xxx.py

# 使用python 3.x的解释器
$ python3 xxx.py
```

**其他解释器（知道）**

Python 的解释器 如今有多个语言的实现、包括：

* CPython —— 官方版本的 C 语言实现
* JPython —— 可以运行在Java平台
* IronPython —— 可以运行在 .NET 和 Mono平台
* PyPy —— Python实现的，支持 JIT 即时编译

#### 3.2 交互式运行Python程序

* 直接在终端中运行解释器，而不输入要执行的文件名
* 在Python 的 shell 中直接输入**Python的代码** ，会立即看到程序执行的结果

**1）交互式运行Python的优缺点**

**优点**

* 适合于学习/验证 Python 语法或者局部代码

**缺点**

* 代码不能保存
* 不适合运行太大的程序

**2）退出 官方的解释器**

​	**1> 直接输入exit()**

```python
>>>> exit()
```

​	2> 使用热键退出

​	在python 解释器中，按热键`ctrl+d`可以退出解释器

**3）IPython**

* IPython 中的 “I” 代表 **交互 Interactive**

**特点**

* IPython 是一个python的 **交互式shell** ，比默认的 python shell 好用
  * 支持自动补全
  * 自动缩进
  * 支持bash shell命令
  * 内置了许多有用的功能和函数
* IPython 是基于 **BSD** 开源的

**版本**

* Python 2.x 使用的解释器是ipython
* 3.x 使用的解释器是 ipython3
* 要退出解释器可以有以下两种方式：

**1>** 直接输入**exit**

**2>** 使用热键退出

在IPython解释器中，按热键`ctrl+d`, 会询问是否退出解释器



#### 3.3 Python 的 IDE —— PyCharm

**1) 集成开发环境（IDE）**

集成开发环境（IDE，Integrated Development Environment）—— **集成开发软件需要的所有工具**，一般包括以下工具：

* 图形用户界面
* 代码编辑器（支持 **代码补全/自动缩进**）
* 编译器/解释器
* 调试器（**断点/单步执行**）
* ......

**2) PyCharm 介绍**

* `PyCharm` 是Python 的一款非常优秀的集成开发环境
* `PyCharm` 除了具有一般IDE所必备功能外，还可以在 **windows \ linux \ macOS** 下使用
* `PyCharm` 适合开发大型项目
  * 一个项目通常会包含 **很多源文件**
  * 每个 **源文件** 的代码行数是有限的，通常在几百行之内
  * 每个 **源文件** 各司其职，共同完成复杂的业务功能

**3) PyCharm 快速体验**

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201120142302329.png" alt="image-20201120142302329" style="zoom:80%;" />

* **文件导航区域** 能够 浏览、定位、打开 项目文件
* **文件编辑区域** 能够 **编辑** 当前打开的文件
* **控制台区域** 能够：
  * 输出程序执行内容
  * 跟踪调试代码的执行
* 右上角的 **工具栏** 能够 **执行 调试** 代码

**lesson 134 Pycharm的初始设置1**
## PyCharm 的初始设置（知道）

**目标**

* 恢复PyCharm 的初始设置
* 第一次启动 PyCharm
* 新建一个 Python 项目
* 设置 PyCharm 的字体显示
* PyCharm 的升级以及其他

PyCharm 的官方网址是：https://www.jerbrains.com/pycharm



### 01. 恢复PyCharm的初始设置

PyCharm **的配置信息** 是保存在 **用户家目录下**的 `.PyCharmxxxx.x` 目录下的，`xxxx.x` 表示当前使用的PyCharm的版本好

> ***本机版本为2018CE.3.7 与课件中的配置略有不同，配置文件在 /Users/derek/Library/Application Support/PyCharmCE2018.3 下，注意，文件名开头没有 `.`***

如果要恢复 PyCharm 的初始设置，可以按照如下步骤进行：

1. 关闭正在运行的 PyCharm
2. 在终端中执行以下终端命令，删除 PyCharm 的配置信息目录：

```shell
$ rm -r ~/.PyCharm2016.3
```

3. 重新启动 PyCharm

### 02. 第一次启动 PyCharm

1. 导入配置信息
2. 选择许可协议
3. 配置初始界面

#### 2.1 导入配置信息

* 在第一次启动 Pycharm 时，会首先提示用户是否导入 **之前的配置信息**
* 如果是第一次使用，直接点击 **OK** 按钮

（图略）

#### 2.2 选择许可协议

* PyCharm 是一个付费软件，购买费用为 199$/年 或 19.9$/月
* 不过PyCharm提供了对 **学生和教师免费试用的版本**
  * 下载地址是：https://www.jetbrains.com/pycharm-edu/download/#section=linux
* 商业版本会提示输入注册信息，或者选择免费评估

（图略）

#### 2.3 PyCharm的配置初始界面

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201123100430178.png" alt="image-20201123100430178" style="zoom:80%;" />

### 03. 新建/打开一个Python项目

#### 3.1 项目简介

* 开发 **项目** 就是开发一个 **专门解决一个复杂业务功能的软件**
* 通常每一个项目 就具有一个 **独立专属的目录**，用于保存 **所有和项目相关的文件**
  * 一个项目通常会包含 **很多源文件**

#### 3.2 打开Python项目

* 直接点击 **Open** 按钮，然后浏览到之前保存 **Python** 文件的目录，既可以打开项目
* 打开之后，会在目录下新建一个 `.idea`的目录，用于保存 **项目相关的信息**，例如：**解释器版本、项目包含的文件**等等
* 第一次打开项目，需要耐心等待 PyCharm对项目 **进行初始化设置**

![image-20201123101632820](/Users/derek/Library/Application Support/typora-user-images/image-20201123101632820.png)

**设置项目使用的解释器版本**

* 打开的目录如果不是由 PyCharm 简历的项目目录，**有的时候** 使用的解释器版本是 `Python 2.x`的，**需要单独设置解释器的版本**
* 通过File / Setting... 可以打开设置窗口，如下图所示

![image-20201123101854577](/Users/derek/Library/Application Support/typora-user-images/image-20201123101854577.png)



#### 3.3 新建项目

**1）命名规则**

* 以后 **项目名** 前面都以 **数字编号**，**随着知识点递增，编号递增**
  * 例如：**01_Python基础**、**02_分支**、**03_循环**
* 每个项目下的 **文件名** 都以 `hm_xx_知识点`方式命名
  * 期中 **xx** 是演练文件的序号
* 注意
  * 1.命名文件名时建议只使用 **小写字母、数字**和 **下划线**
  * 2.**文件名不能以数字开始**

**2）演练步骤**

* 新建 `01_Python基础`项目，使用 **`Python 3.x`解释器**
* 在项目下新建 `hm_01_hello.py` Python文件
* 编写 `print("hello python")` 代码

**lesson 135 Pycharm的初始设置2**

### 04. 设置 PyCharm字体显示



<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201123105814947.png" alt="image-20201123105814947" style="zoom:60%;" />



<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201123105909298.png" alt="image-20201123105909298" style="zoom:60%;" />



### 05.PyCharm 的升级以及其他

> *PyCharm 提供了对 **学生和教师免费使用的版本***

* 教育版：https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=mac
* 专业版：https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=mac&code=PCC

#### 5.1 安装和启动步骤

* 1. 执行以下终端命令，解压缩下载后的安装包

```shell
$ tar -zxvf pycharm-professional-2017.1.3.tar.gz
```

* 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用

> *`/opt`  目录用户存放给主机额外安装的软件*

```shell
$ sudo mv pycharm-2017.1.3 /opt/
```

* 3. 切换工作目录

```shell
$ cd /opt/pycharm-2017.1.3/bin
```

* 4. 启动 `PyCharm`

```shell
$ ./pycharm.sh
```

#### 5.2 设置专业版启动图标

* 在**专业版** 中，选择菜单 Tools/ Create Desktop Entry... 可以设置任务栏启动图标
  * 注意：设置图标时， 需要勾选 `Create the entry for all users`

![image-20201123142105676](/Users/derek/Library/Application Support/typora-user-images/image-20201123142105676.png)

#### 5.3 卸载之前版本的PyCharm

**1）程序安装**

* 1. 程序安装目录

  * 将安装包解压缩，并且移动到 `/opt` 目录下
  * **所有相关文件都保存在解压缩的目录中**

* 2. 配置文件目录

  * 启动 PyCharm 后，会在用户家目录下建立一个 .PyCharmxxxx 的隐藏目录
  * **保存 PyCharm 相关的配置信息**

* 3. 快捷方式文件

  * `/usr/share/applications/jetbrain-pycharm.desktop`

> *在 `ubuntu`中，应用程序启动的快捷方式通常都保存在 /usr/share/applications 目录下*

**2）程序卸载**

* 要卸载 PyCharm 只需要做以下两步工作：

* 1. 删除解压缩目录

```shell
$ sudo rm -r /opt/pycharm-2016.3.1/
```

* 2. 删除家目录下用于保存配置信息的隐藏目录

```shell
$ rm -r ~/.PyCharm2016.3
```

> ***如果不再使用PyCharm 还需要将*** *`/usr/share/applications/` 下的 `jetbrain-pycharm.desktop` 删掉*

#### 5.4 教育版安装演练

```shell
# 1.解压缩下载后的安装包
$ tar -zvxf pycharm-edu-3.5.1.tar.gz

# 2.将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用
$ sudo mv pycharm-edu-3.5.1/ /opt/

# 3.启动 `PyCharm`
$ /opt/pycharm-edu-3.5.1/bin/pychar.sh
```

> 后续课程使用**专业版本演练**

**设置启动图标**

* 1.编辑快捷方式文件

```shell
$ sudo gedit /usr/share/applications/jetbrains-pycharm.desktop
```

* 3. 按照以下内容修改文件内容，需要注意 **指定正确的** pycharm 目录

```shell
[Desktop Entry]
Version=1.0
Type=Application
Name=PyCharm
Iron=/opt/pycharm-edu-3.5.1/bin/pycharm.png
Exec="/opt/pycharm-edu-3.5.1/bin/pycharm.sh" %f
Comment=The Drive to Develop
Categories=Development;IDE;
Terminal=false
StartupWMClass=jetbrains-pycharm
```

### 多文件项目的演练

* 开发 **项目** 就是开发一个 **专门解决一个复杂业务功能的软件**
* 通常每一个项目 就具有一个 **独立专属的目录**，用于保存 **所有和项目相关的文件**
  * 一个项目通常会包含 **很多源文件**

**目标**

* 在项目中添加多个文件，并且设置文件的执行

**多文件项目演练**

1. 在 `01_Python基础` 项目中新建一个 `hm_02_第二个python程序.py`
2. 在 `hm_02_第二个python程序.py` 文件中添加一句 `print("hello ")`
3. **点击右键执行** `hm_02_第二个python程序.py`

![image-20201123145402539](/Users/derek/Library/Application Support/typora-user-images/image-20201123145402539.png)

**提示**

* 在 PyCharm中，要想让哪一个Python程序能够执行，必须首先通过 **鼠标右键的方式执行以下**
* 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试
* 对于商业项目而言，通常在一个项目中，只有一个 **可以直接执行的Python源程序**



**lesson 136 程序注释和算数运算**



## 注释

**目标**

* 注释的作用
* 单行注释（行注释）
* 多行注释（块注释）

### 01. 注释的作用

> *使用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性*

### 02. 单行注释（行注释）

* 以 `#` 开头，`#` 右边的所有东西都被当作说明文字，而不是真正要执行的程序，只起到辅助说明的作用
* 示例代码如下：

```python
# 这是一个单行注释
print("hello python")
```

> *为了保证代码的可读性，`#` 后面建议添加一个空格，然后再编写对应的说明文字*

**在代码后面增加的单行注释**

* 在程序开发时，同样可以使用`#` 在代码后面（旁边）增加说明性文字
* 但是需要注意，**为了保证代码的可读性，注释和代码之间** 至少要有 **两个空格**
* 示例代码如下：

```python
print("hello python")  # 输出 hello python
```

### 03. 多行注释（块注释）

* 如果希望编写的 **注释信息很多，一行无法显示，** 就可以使用多行注释
* 要在 Python 程序中使用多行注释，可以用 一对 **连续的三个银行** （单、双银行皆可）
* 示例代码如下：

```python
'''
这是一个多行注释
在多行注释之间，可以写很多很多的内容......
'''

print("hello python!")
```

**什么时候需要使用注释**

1. **注释不是越多越好，** 对于一目了然的代码，不需要添加注释
2. 对于 **复杂的操作，** 应该在操作开始前写上若干注释
3. 对于 **不是一目了然的代码，** 应在其行尾添加注释（为了提高可读性，注释应该至少离开代码2个空格）
4. 绝不要描述代码，假设阅读代码的人比你更懂Python，他只是不知道你的代码要做什么

> *在一些正规的开发团队，通常会有 **代码审核** 的惯例，就是一个团队中彼此阅读对方的代码*

**关于代码规范**

* `Python`官方提供有一系列 PEP(Python Enhancement Proposals) 文档
* 其中第8篇文档专门针对**Python 的代码格式** 给出了建议，也就是俗称的 **PEP 8**
* 文档地址： https://www.python.org/dev/peps/pep-0008
* 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/

> ***任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步***

## 算数运算符

计算机，顾名思义就是负责进行 **数学计算** 并且 **存储计算结果** 的电子设备

**目标**

* 算数运算符的基本使用

### 01. 算数运算符

* 算数运算符是 **运算符的一种**
* 是完成基本的算术运算使用的符号，用来处理四则运算

| 运算符 |  描述  | 实例                                    |
| :----: | :----: | :-------------------------------------- |
|   +    |   加   | 10 + 20 = 30                            |
|   -    |   减   | 10 - 20 = -10                           |
|   \*   |   乘   | 10 * 20 = 200                           |
|   /    |   除   | 10 / 20 = 0.5                           |
|   //   | 取整除 | 返回出发的整数部分（商） 9//2 输出结果4 |
|   %    | 取余数 | 返回除法的余数 9%2 = 1                  |
|  \*\*  |   幂   | 又称次方、乘方，2**3 = 8                |

* Python中，`*`运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果

```python
In [1]: "-" * 50
Out[1]: '--------------------------------------------------'
```

### 02. 算数运算符的优先级

* 和数学中的运算符的优先级一致，在Python 中进行数学计算时，同样也是：
  * **先乘除后加减**
  * 同级运算符是 **从左至右** 计算
  * 可以使用`()`调整计算的优先级
* 以下表格的算数优先级由高到低顺序排列

| 运算符            | 描述                   |
| ----------------- | ---------------------- |
| `**`              | 幂（最高优先级）       |
| `*`  `/` `%` `//` | 乘、除、取余数、取整除 |
| `+` `-`           | 加法、减法             |

**lesson 137 程序执行原理**

##  程序执行原理（科普）

**目标**

* 计算机中的 **三大件**
* 程序执行的原理
* 程序的作用

### 01. 计算机中的三大件

计算机中包含有较多的硬件，但是一个程序要运行，有 **三个** 核心的硬件，分别是：

1. **CPU**
   * 中央处理器，是一块超大规模的集成电路
   * 负责 **处理数据/计算**
2. **内存**
   * **临时** 存储数据（断电之后，数据会消失）
   * 速度快
   * 空间小
   * 价格高
3. **硬盘**
   * **永久** 存储数据
   * 速度慢
   * 空间大
   * 价格便宜

|                             CPU                              |                             内存                             |                             硬盘                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image-20201104213357079](/Users/derek/Library/Application Support/typora-user-images/image-20201104213357079.png) | ![image-20201104213412062](/Users/derek/Library/Application Support/typora-user-images/image-20201104213412062.png) | ![image-20201104213430990](/Users/derek/Library/Application Support/typora-user-images/image-20201104213430990.png) |

**思考题**

（略）

### 02. 程序的执行原理

![image-20201104214119124](/Users/derek/Library/Application Support/typora-user-images/image-20201104214119124.png)

1. 程序 **运行之前，** 程序是 **保存在硬盘** 中的
2. 当要运行一个程序时
   * 操作系统会首先让 **CPU** 把程序复制到 **内存** 中
   * **CPU** 执行 **内存** 中的 **程序代码**

> ***程序要执行，首先要被加载到内存中***

#### 2.1 python程序的执行原理

![image-20201104214734290](/Users/derek/Library/Application Support/typora-user-images/image-20201104214734290.png)

1. 操作系统会首先让 **CPU** 把 **Python解释器** 的程序复制到 **内存中**
2. **Python解释器** 根据语法规则，**从上到下** 让  **CPU** 翻译 **Python 程序中的代码**
3. **CPU** 负责执行翻译完成的代码

Python 的解释器有多大？

* 执行以下终端命令可以查看Python 解释器的大小

```shell
# 确认解释器所在的位置
$ which python
/Users/derek/opt/anaconda3/bin/python
# 查看 python 文件大小（只是一个软链接）
$ ls -lh /Users/derek/opt/anaconda3/bin/python
lrwxr-xr-x  1 derek  staff     9B  4 27  2020 /Users/derek/opt/anaconda3/bin/python -> python3.7
# 查看具体的文件大小
$ ls -lh /Users/derek/opt/anaconda3/bin/python3.7
-rwxrwxr-x  1 derek  staff   4.0M  4 27  2020 /Users/derek/opt/anaconda3/bin/python3.7
```

> *提示：建立 **软链接** 的目的，是为了方便使用者不用记住使用的解释器时 **哪一个具体版本***

### 03. 程序的作用

> *程序就是 **用来处理数据** 的*

* **新闻软件** 提供的 **新闻内容、评论 ......** 是数据
* **电商软件** 提供的 **商品信息、配送信息 ......** 是数据
* **运动类软件** 提供的 **运动数据 ......** 是数据
* **地图类软件** 提供的 **地图信息、定位信息、车辆信息 ......** 是数据
* **即时通讯软件** 提供的 **聊天信息、好友信息 ......** 是数据
* **......**

#### 3.1 思考QQ的启动过程

1. QQ **在运行之前** ，是保存在 **硬盘** 中的
2. **运行之后**，QQ程序就会被加载到 **内存** 中了

![image-20201104220604893](/Users/derek/Library/Application Support/typora-user-images/image-20201104220604893.png)

#### 3.2 思考 QQ 程序的登录过程

1. 读取用户输入的 **QQ号码**
2. 读取用户输入的 **QQ密码**
3. 将 **QQ号码** 和 **QQ密码** 发送给服务器，等待服务器确认用户信息

**思考1**

> *在QQ这个程序将 **QQ号码** 和 **QQ密码** 发送给服务器之前，**是否需要先存储一下QQ号码 和 密码** *
>
> 答案：肯定需要 —— 否则 QQ这个程序就不知道把什么内容发送给服务器了

**思考2**

>*QQ 把 **号码** 和 **密码** 保存在哪里*
>
>答案：保存在内存中

**思考3**

> QQ 怎么保存用户的 **号码** 和 **密码** 的？
>
> 答案：
>
> 1. 在内存中为 **号码** 和 **密码** 各自分配一块空间
>    * 在QQ程序结束之前，这两块空间是由QQ程序负责管理的，其他任何程序都不允许使用
>    * 在QQ自己使用完成之前，这两块儿空间始终都只负责保存 **号码** 和 **密码** 
> 2. 使用一个 **别名** 标记 QQ**号码** 和 **密码** 在内存中的位置

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201105092742335.png" align="left" alt="image-20201105092742335" style="zoom:80%;" />

> * *在程序内部，为 **QQ号码** 和 **QQ密码**  在内存中分配的空间就叫做 **变量***
> * ***程序就是用来处理数据的***，***而变量就是用来保存数据的***

**lesson 138 变量使用及类型**

## 变量的基本使用

**目标**

* 变量定义
* 变量的类型
* 变量的命名

### 01. 变量定义

* 在Python中，每个变量 **在使用前都必须赋值**，变量 赋值以后 该变脸 **才会被创建**
* 等号（=）用来给变量赋值
  * `=`左边是一个变量名
  * `=`右边是存储在变量中的值

```
变量名 = 值
```

> *变量定义之后，后续就可以直接使用了*

**1) 变量演练1 —— iPython**

```python
# 定义qq_number 的变量用来保存号码
In [1]: qq_number = '1234567'

# 输出 保存内容
In [2]: qq_number
Out[2]: '1234567'

# 定义qq_password 的变量用来保存 密码
In [3]: qq_password = '123'

# 输出 保存内容
In [4]: qq_password
Out[4]: '123'
```

> ***使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用`print`函数***

**2）变量演练2 —— PyCharm**

```python
# 定义qq号码变量
qq_number = '1234567'

# 定义qq密码变量
qq_password = '123'

# 输出变量保存的内容，使用print函数
print(qq_number)
print(qq_password)

```

> ***使用解释器执行，如果要输出变量的内容，必须要使用`print`函数***

**3）变量演练3 —— 超市买苹果**

> * *可以用 **其他变量的计算结果** 来定义变量*
> * *变量定义之后，后续就可以直接使用了*

**需求**

* 苹果的价格是 8.5元/斤
* 买了 7.5 斤苹果
* 计算付款金额

```python
# 定义苹果价格变量
price = 8.5

# 定义购买重量
weight = 7.5

# 计算金额
money = price * weight

print(money)
```

**思考**

* 如果 **只要买苹果，就返回5块钱**
* 请重新计算购买金额

```python
price = 8.5

weight = 7.5

money = price * weight

money = money -5

print(money)
```

**提问**

* 上述代码中，一共定义了几个变量
  * 三个：price / weight /money
* money = money - 5 时在定义新的变量还是在使用变量
  * 直接使用之前已经定义的变量
  * 变量名 只有在 **第一次出现** 才是 **定义变量**
  * 变量名再次出现，不是定义变量，而是直接使用之前已经定义过的变量
* 在程序开发中，可以修改之前定义变量中保存的值么
  * 可以
  * 变量中存储的值，就是可以 **变** 的

### 02. 变量的类型

* 在内存中创建一个变量，会包括
  1. 变量的名称
  2. 变量保存的数据
  3. 变量存储数据的类型
  4. 变量的地址（标示）

#### 2.1 变量类型的演练 —— 个人信息

**需求**

* 定义变量保存小明的个人信息
* 姓名：**小明**
* 年龄：**18**
* 性别：**男生**
* 身高：**1.75米**
* 体重：**75.0公斤**

> *利用 **单步调试** 确认变量中保存的数据类型*

**提问**

1. 在演练中，一共有几种数据类型
   * 4种
   * `str` —— 字符串
   * `bool` —— 布尔（真假）
   * `int` —— 整数
   * `float` —— 浮点数（小数）
2. 在 Python 中定义变量需要指定类型么
   * 不需要
   * Python 可以根据 `=` 等号右边的值，自动推导出变量中存储数据的类型



#### 2.2 变量的类型

* 在Python 中定义变量是 **不需要指定类型** （在其他很多高级语言中都需要）

* 数据类型可以分为 **数字型** 和 **非数字型**

* 数字型

  * 整型（`int`）
  * 浮点型（`float`）
  * 布尔型（`bool`）
    * 真 `True` ` 非0数` —— **非零即真**
    * 假 `False`  `0`
  * 复数型（complex）
    * 主要用于科学计算，例如：平面场问题、波动问题、电感电容问题
  * 非数字型
    * 字符串
    * 列表
    * 元组
    * 字典

  > *提示：在**Python 2.x** 中，**整数** 根据保存数值的长度还分为：*
  >
  > * `int`（整数）
  > * `long`（长整数）

```
  In [1]: type(2**64)
  Out[1]: int

  In [2]: print(2**64)
  18446744073709551616
```

  > ***尾部不再`long`类型的有`L`***
  > ***python 3.x中，不再有`long`类型***

  * 使用 type 函数可以查看一个变量的类型

```
In [8]: type(a)
Out[8]: list
```

**lesson 139 变量的计算和输入输出**

#### 2.3 不同类型变量之间的计算

**1）数字型变量 之间可以直接计算**

* 在Python中，两个数字型变量是可以直接进行 算数运算的
* 如果变量是 bool 型，在计算时
  * `True`对应的数字是 `1`
  * `False`对应的数字是 `0`

**演练步骤**

1. 定义整数 `i = 10`
2. 定义浮点数  `f = 10.5`
3. 定义浮点数 `b = True`

* 在IPython中，使用上述三个变量相互进行算术运算

**2）字符串变量 之间使用 + 拼接字符串**

* 在Python中，字符串之间可以使用 `+` 拼接生成新的字符串

```
In [3]: first_name = "三"

In [4]: last_name = "张"

In [5]: first_name + last_name
Out[5]: '三张'
```

**3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串**

```
In [6]: "-" * 50
Out[6]: '--------------------------------------------------'
```

**4）数字型变量 和 字符串 之间 不能进行其他计算**

```
In [9]: first_name
Out[9]: '三'

In [10]: first_name + 10
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-10-9cdb04e21ce8> in <module>
----> 1 first_name + 10

TypeError: can only concatenate str (not "int") to str
```



#### 2.4 变量的输入

* 所谓 **输入** ，就是 **用代码** 获取 用户通过 **键盘** 输入的信息
* 例如：银行ATM取款，输入密码
* 在Python中，如果要获取用户在 **键盘** 上的输入信息，需要使用到 `input`函数

**1）关于函数**

* 一个 **提前准备好的功能** **可以直接使用** 而**不用关心内部细节**
* 目前已经学习过的函数
  * print(x)
  * type(x)

**2) input函数实现键盘输入**

* 在Python中可以使用`input`函数从键盘等待用户的输入
* 用户输入的 **任何内容** Python 都认为是一个字符串
* 语法如下：

```python
str1 = input("提示信息：")
```

**3) 类型转换函数**

| **函数** | **说明**            |
| :------- | ------------------- |
| int(x)   | 将x转换为一个整数   |
| float(x) | 将x转换为一个浮点数 |



4）演练 —— 超市买苹果

**需求**

* **收银员输入** 苹果的价格，单位：元/斤
* 收银员输入 用户购买苹果的重量，单位：斤
* 计算并且 **输出** 付款金额

**演练方式1**

```python
# 1. 输入苹果价格
price_str = input("苹果单价：")

# 2. 要求苹果重量
weight_str = input("苹果重量：")

# 3. 计算金额
# 将价格转换成小数
price = float(price_str)
# 将重量转换成小数
weight = float(weight_str)
money = price * weight
print(money)

```

**演练方式2 —— 改进版**

1. **定义一个 浮点变量** 接收用户输入的同时，就使用`float`函数进行转换

```python
price = float(input("苹果单价："))
```

* 改进后优点：

1. 节约空间，只需要为一个变量分配空间
2. 起名字方便，不需要为中间变量起名字

* 改进后缺点：

1. 初学者需要知道，两个函数能够 **嵌套** 使用

**提示**

* 如果输入的不是一个数字，程序执行时会报错

#### 2.5 变量的格式化输出

> *苹果单价 9.00 元/斤 ，购买了 5.00 斤，需要支付 45.00 元*

* 在Python中可以使用 print 函数将信息输出到控制台
* 如果希望输出信息的同时，**一起输出 数据**，就需要使用到 **格式化操作符**
* `%` 被称为 **格式化操作符**，专门用于处理字符串中的格式
  * 包含`%` 的字符串，被称为 **格式化操作符**
  * `%`和不同的字符连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| **格式化字符** | **含义**                                                     |
| -------------- | ------------------------------------------------------------ |
| `%s`           | 字符串                                                       |
| `%d`           | 有符号十进制整数，`%06d`标示输出的整数显示位数，不足的地方使用 **0** 部全 |
| `%f`           | 浮点数，`%.02f` 表示小数点后只显示两位                       |
| `%%`           | 输出%                                                        |

* 语法格式如下：

```python
print("格式化字符串" % 变量1)
print("格式化字符串" % (变量1, 变量2))
```

**格式化输出演练 —— 基本练习**

```python
# 定义字符串变量 name ，输出 我的名字叫 小明，请多多关照
name = "小明"
print("我的名字叫 %s，请多多关照" % name)

# 定义整数变量 student_no, 输出 我的学号是 000001
student_no = 1
print("我的学号是 %06d" % student_no)

# 定义小数price weight money，
# 输出 苹果单价 9.00元/斤，购买了 5.00斤, 需要支付 45.00元
price = 9.0
weight = 5.0
money = price * weight
print("苹果单价 %.02f元/斤 购买了 %.02f斤, 需要支付 %.04f元"
      % (price, weight, money))

# 定义了一个小数 scale，输出 数据比例是 10.00%
scale = 0.25
print("数据比例是 %.2f%%" % (scale * 100))
```

**lesson 140 变量的命名**

## 变量的命名

**目标**

* 标识符和关键字
* 变量的命名规则

### 01. 标识符和关键字

#### 1.1 标识符

> 标识符就是程序员定义的 **变量名、函数名**
>
> **名字** 需要有 **见名知意** 的效果

* 标识符可以由 **字母、下划线、数字** 组成
* **不能以数字开头**
* **不能与关键字重名**

思考：下面的标识符哪些是正确的，哪些不正确，为什么？

```python
fromNo12
from#12
my_Boolean
my-Boolean
obj2
2ndbj
myInt
My_tExt
_test
test!32
haha(da)tt
jack_rose
jack&rose
GUI
G.U.I
```

#### 1.2 关键字

* **关键字** 就是在 `Python` 内部已经使用的标识符
* **关键字** 具有特殊的功能和含义
* 开发者 **不允许定义和关键字相同的名字和标识符**

通过以下命令可以查看 `Python` 中的关键字

```python
In [18]: import keyword

In [19]: print(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

```

> *提示：**关键字的学习及使用，** 会在后面的课程中不断介绍*
>
> * *import **关键字** 可以导入一个 **“工具包”***
> * *在 Python 中不同的工具包，提供有不同的工具*

### 02. 变量的命名规则

> * *命名规则 可以被视为一种 **惯例** ，并无绝对与强制*
>
> * 目的是为了 **增加代码的识别和可读性**

**注意：** `Python`中的 **标识符** 是 **区分大小写的**

![image-20201106162529354](/Users/derek/Library/Application Support/typora-user-images/image-20201106162529354.png)

1. 在定义变量时，为了保证代码格式， `=` 的左右应该各保留一个空格
2. 在 `Python`中，如果 **变量名** 需要由**两个** 或 **多个单词** 组成时，可以按照以下方式命名
   1. 每个单词都适用小写字母
   2. 单词与单词之间使用 `_` **下划线**连接
   3. 例如：`first_name`、 `last_name`、 `qq_number`、 `qq_password`

**参见[命名]**
https://github.com/zh-google-styleguide/zh-google-styleguide/blob/master/google-python-styleguide/python_style_rules.rst

**驼峰命名法**

* 当 **变量名** 是由 二个 或 多个单词 组成的，还可以利用驼峰命名法来命名
* **小驼峰命名法**
  * 第一个单词以小写字母开始，后续单词的首字母大写
    * 例如： `firstName`、 `lastName`
* **大驼峰命名法**
  * 每一个单词的首字母采用大写
  * 例如：`FirstName`、 `LastName` 、`CanelCase`

![image-20201106163708787](/Users/derek/Library/Application Support/typora-user-images/image-20201106163708787.png)

**lesson 141 if判断语句1**

## 判断（if）语句

**目标**

* 开发中的应用场景
* if语句体验
* if语句进阶
* 综合应用

### 01. 开发中的应用场景

生活中的判断几乎无处不在，我们每天都在做各种各样的选择，如果这样，如果那样。。。

![image-20201106164027124](/Users/derek/Library/Application Support/typora-user-images/image-20201106164027124.png)



**程序中的判断**

![image-20201106164051112](/Users/derek/Library/Application Support/typora-user-images/image-20201106164051112.png)

```python
if 今天发工资:
  
	先还信用卡
	
  if 有剩余:
		
    又可以happy了
	
  else:
		
    no... 再等30天
else:
	
  盼着发工资
```

**判断的定义**

* 如果 **条件满足** ，才能做某件事情
* 如果 **条件不满足** ，就做另外一件事情，或者什么也不做

> *正是因为有了判断，才使程序世界丰富多彩，充满变化*
>
> *判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序又了很多分支*

### 02. if语句体验

#### 2.1 if判断语句基本语法

在`Python`中， **if语句** 就是用来进行判断的，格式如下：

```python
if 要判断的条件:
  条件成立时，要做的事
  ......
```

> *注意：代码的缩进为一个`tab` 键，或者 **4** 个空格 —— **建议使用空格***
>
> * *在Python开发中，Tab 和 空格不要混用*

**我们可以把整个if语句看成一个完整的代码块**

![image-20201107105155663](/Users/derek/Library/Application Support/typora-user-images/image-20201107105155663.png)

#### 2.2 判断语句演练 —— 判断年龄

**需求**

1. 定义一个整数变量记录年龄
2. 判断是否满18岁 (>=)
3. 如果满18岁，允许进网吧

```python
# 1. 定义年龄变量
age = 18

# 2. 判断是否满18岁
if age >= 18:
    # 3. 如果满了18岁，可以进网吧
    print("已经成年，欢迎进网吧")
# 4. 思考- 无论条件是否满足都会执行
print("这句代码什么时候执行")
```

**注意：**

* if 语句以及缩进部分是一个 **完整的代码块**



#### 运算符

**目标**

* 比较（关系）运算符
* 逻辑运算符
* 运算符的优先级

数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表

##### 01. 比较（关系）运算符

| **运算符** | **描述**                                                     |
| :--------- | :----------------------------------------------------------- |
| ==         | 检查两个操作数的值是否 **相等** ，如果是，条件成立，返回True |
| !=         | 检查两个操作数的值是否 **不相等** ，如果是，条件成立，返回True |
| >          | 检查左操作数的值是否 **大于** 右操作数的值，如果是，条件成立，返回True |
| <          | 检查左操作数的值是否 **小于** 右操作数的值，如果是，条件成立，返回True |
| >=         | 检查左操作数的值是否 **大于或等于** 右操作数的值，如果是，条件成立，返回True |
| <=         | 检查左操作数的值是否 **小于或等于** 右操作数的值，如果是，条件成立，返回True |

>*Python 2.x 中判断 **不等于** 还可以用 `<>` 运算符*
>
>*`!=` 在 Python 2.x 中同样可以用来判断 **不等于***



#### 2.3 else 处理条件不满足的情况

**思考**

在使用 `if` 判断时，只能做到满足条件时要做的事情。那如果需要在 **不满足条件的时候，** 做某些事情，该如果做么？

**答案**

`else` ， 格式如下：

```python
if 要判断的条件：
	条件成立时，要做的事情
  ......
else:
  条件不成立时，要做的事情
  ......
```

**注意**

* if 和 else 语句以及各自的缩进部分共同是一个 **完整的代码块**

#### 2.4 判断语句演练 —— 判断年龄改进

**需求**

1. 输入用户年龄
2. 判断是否满 18 岁
3. 如果满18岁，允许进网吧
4. 如果未满18岁，提示回家写作业

```python
# 1. 输入用户年龄
age = int(input("请输入你的年龄："))

# 2. 判断是否满18岁
if age >= 18:
    # 3. 如果满了18岁，可以进网吧
    print("已经成年，欢迎进网吧")
else:
    # 4. 如果未满18岁，提示回家写作业
    print("回家写作业")
    
# 这句代码无论条件成立，都会执行
print("这句代码什么时候执行")
```



**lesson 142 if判断语句2**

### 03. 逻辑运算

* 在程序开发中，通常 **在判断条件时**， 会需要同时判断多个条件
* 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 **逻辑运算符**
* **逻辑运算符** 可以把 **多个条件** 按照 **逻辑** 进行 **连接** ，变成 **更复杂的条件**
* Python中的 **逻辑运算符** 包括： **与and** / **或 or** / **非 not**

#### 3.1 and

```
条件1 and 条件2
```



* **与/并且**
* 两个条件同时满足，返回 `True`
* 只要有一个条件不满足，就返回 `False`

|**条件1**|**条件2**|**结果**|
|:----:|:----:|:----:|
|成立|成立|成立|
|成立|不成立|不成立|
|不成立|成立|不成立|
|不成立|不成立|不成立|

#### 3.2  or

```
条件1 or 条件2	
```

* **或/或者**
* 两个条件只要有一个满足，返回`True`

* 两个条件都不满足，返回 `False`

| **条件1** | **条件2** | **结果** |
| :-------: | :-------: | :------: |
|   成立    |   成立    |   成立   |
|   成立    |  不成立   |   成立   |
|  不成立   |   成立    |   成立   |
|  不成立   |  不成立   |  不成立  |

#### 3.3 not

```
not 条件	
```

* **非/不是**

| **条件** | 结果   |
| -------- | ------ |
| 成立     | 不成立 |
| 不成立   | 成立   |

**逻辑运算演练**

1. 练习1: 定义一个整数变量 `age` , 编写代码判断年龄是否正确
   * 要求人的年龄在0-120 之间
2. 练习2: 定义两个整数变量 `Python_score` \ `c_score` , 编写代码判断成绩
   * 要求只要有一门成绩 >60 分就算合格
3. 练习3: 定义一个布尔型变量 `is_employee`, 编写代码判断是否是本公司员工
   * 如果不是提示不允许入内

```python
# 练习1: 定义一个整数变量 `age` , 编写代码判断年龄是否正确
age = 12

# 要求人的年龄在0-120 之间
if 0 <= age <= 120:
    print("年龄正确")
else:
    print("年龄不正确")

# 练习2: 定义两个整数变量 `Python_score` \ `c_score` , 编写代码判断成绩
python_score = 80
c_score = 6
# 要求只要有一门成绩 >60 分就算合格
if python_score > 60 or c_score > 60:
    print("考试合格")
else:
    print("不及格")

# 练习3: 定义一个布尔型变量 `is_employee`, 编写代码判断是否是本公司员工
is_employee = False

# 如果不是提示不允许入内
if not is_employee:
    print("非本公司员工，禁止入内")
```



### 04. if 语句进阶

#### 4.1 elif

* 在开发中，使用 `if` 可以 **判断条件**
* 使用 `else` 可以处理 **条件不成立** 的情况
* 但是，如果希望 **再增加一些条件，条件不同，需要执行的代码也不同** 时，就可以使用 `elif`
* 语法格式如下：

```python
if 条件1:
  条件1满足执行的代码
  ......
elif 条件2:
  条件2满足执行的代码
  ......
elif 条件3:
  条件3满足执行的代码
  ......
else:
  以上条件都不满足时，执行的代码
  ......
```

* 对比逻辑运算符的代码

```python
if 条件1 and 条件2:
  条件1满足 并且 条件2满足 执行的代码
  ......
```

**注意**

1. `elif` 和 `else` 都必须和 `if` 联合使用，而不能单独使用
2. 可以将  `if` 、`elif` 和 `else`以及缩进的代码，看成一个 **完整的代码块**

**elif演练 —— 女友的节日**

**需求**

1. 定义 `holiday_name` 字符串变脸记录节日名称
2. 如果是 **情人节** 应该 **买玫瑰/看电影**
3. 如果是 **平安夜** 应该 **买苹果/吃大餐**
4. 如果是 **生日** 应该 **买蛋糕**
5. 其他的日子每天都是节日啊...

```python
# 1. 定义 `holiday_name` 字符串变脸记录节日名称
holiday_name = "妇女节"
# 2. 如果是 **情人节** 应该 **买玫瑰/看电影**
if holiday_name == "情人节":
    print("买玫瑰，看电影")
# 3. 如果是 **平安夜** 应该 **买苹果/吃大餐**
elif holiday_name == "平安夜":
    print("买苹果,吃大餐")
# 4. 如果是 **生日** 应该 **买蛋糕**
elif holiday_name == "生日":
    print("买蛋糕")
# 5. 其他的日子每天都是节日啊...
else:
    print("每天都是节日啊")
```



#### 4.2 if的嵌套

![image-20201107221928221](/Users/derek/Library/Application Support/typora-user-images/image-20201107221928221.png)



> *elif 的应用场景是：**同时** 判断 **多个条件** ，所有的条件是 **平级** 的*

* 在开发中，使用 `if` 进行条件判断，如果希望 **在条件成立的执行语句中** 再 **增加条件判断**，就可以使用 **if的嵌套**
* **if的嵌套** 的应用场景就是：**在之前条件满足的前提下，再增加额外的判断**
* **if的嵌套** 的语法格式， **除了缩进之外** 和之前的没有区别
* 语法格式如下：

```python
if 条件1:
	条件1 满足执行的代码
	......
	if 条件1 基础上的条件2:
		条件2 满足时，执行的代码
	# 条件2 不满足的处理
	else:
		条件2 不满足时，执行的代码
# 条件1 不满足的处理
else:
	条件1 不满足时，执行的代码
	......
```



![image-20201107223039015](/Users/derek/Library/Application Support/typora-user-images/image-20201107223039015.png)

**if的嵌套 演练 —— 火车站案件**

**需求**

1. 定义布尔型变量 `has_ticket` 表示是否有车票
2. 定义整型变量 `knife_length` 表示到的长度，单位：厘米
3. 首先检查是否有车票，如果有，允许进行 **安检**
4. 安检时，需要检查刀的长度，判断是否超过20cm
   * 如果超过20厘米，提示刀的长度，不允许上车
   * 如果不超过20厘米，安检通过
5. 如果没有车票，不允许进门

> ***提示，PyCharm中，按住`Tab`增加缩进，按住`shift`+`Tab`减少缩进***

```python
# 1. 定义布尔型变量 `has_ticket` 表示是否有车票
has_ticket = True
# 2. 定义整型变量 `knife_length` 表示到的长度，单位：厘米
knife_length = 20
# 3. 首先检查是否有车票，如果有，允许进行 **安检**
if has_ticket:
    print("车票检查通过，准备开始安检")
    # 4. 安检时，需要检查刀的长度，判断是否超过20cm
    if knife_length > 20:
        # 如果超过20厘米，提示刀的长度，不允许上车
        print("刀的长度：%d, 不允许上车" % knife_length)
        # 如果不超过20厘米，安检通过
    else:
        print("安检通过！")
# 5. 如果没有车票，不允许进门
else:
    print("请先买票")
```



**lesson 143 石头剪刀布**

### 05. 综合应用 —— 石头剪刀布

**目标**

1. 强化 **多个条件** 的 **逻辑运算**
2. 体会 `import` 导入模块 （工具包）的使用

**需求**

1. 从控制台输入要出的拳 —— 石头（1）/剪刀（2）/布（3）
2. 电脑 **随机** 出拳 —— 先假定电脑只会出石头，完成整体代码
3. 比较胜负

| **序号** |   **规则**   |
| :------: | :----------: |
|    1     | 石头 胜 剪刀 |
|    2     |  剪刀 胜 布  |
|    3     |  布 胜 石头  |

#### 5.1 基础代码实现

* 先假定电脑只会出石头，实现整体代码功能

```
computer = 1
其他代码略
```



#### 5.2 随机数的处理

* 在Python中，要使用随机数，首先要导入 **随机数** 的 **模块** —— “工具包”

```python
import random
```

* 导入模块后，可以直接在 **模块名称** 后面敲一个`.` 然后按 `Tab` 键，会提示该模块中包含的所有函数
* `random.randint(a, b)` , 返回 `[a,b]` 之间的整数，包含 `a` 和 `b`
* 例如：

```python
random.randint(12, 20) # 生成的随机数n: 12 <= n <= 20
random.randint(20, 20) # 结果永远是 20
random.randint(20, 10) # 该语句是错误的，下限必须小于上限
```

* 完整代码如下：

```python
import random

lst = ["石头", "剪刀", "布"]
# 1. 从控制台输入要出的拳 —— 石头（1）/剪刀（2）/布（3）
player = int(input("请出拳 石头（1）/剪刀（2）/布（3）："))

# 2. 电脑随机出拳 —— 先假定电脑只会出石头，完成整体代码
computer = random.randint(1, 3)
print("玩家: %s —— 计算机: %s" % (lst[player - 1], lst[computer - 1]))
# 3. 比较胜负
# 1 石头 胜 剪刀
# # 2 剪刀 胜 布
# # 3 布 胜 石头
if ((player == 1 and computer == 2)
        or (player == 2 and computer == 3)
        or (player == 3 and computer == 1)):
    print("玩家胜利")
elif player == computer:
    print("平局")
else:
    print("电脑胜利，再来一盘")
```



**lesson 144 循环目标确定**

## 循环

**目标**

* 程序的三大流程
* while 循环基本使用
* break 和 continue
* while 循环嵌套

### 01. 程序的三大流程

* 在程序开发中，一共有三种流程方式：
  * **顺序** —— **从上到下** ，顺序执行代码
  * **分支** —— 根据条件判断，决定执行代码的 **分支**
  * **循环** —— 让 **特定代码 重复** 执行

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201108221435947.png" alt="image-20201108221435947" style="zoom:80%;" />

**lesson 145 循环三大流程介绍**

**同上**

**lesson 146 循环语法介绍和应用场景**

### 02. while循环基本使用

* 循环的作用就是让 **指定的代码** 重复的执行
* `while` 循环最常用的应用场景就是 **让执行的代码** 按照 **指定的次数 重复** 执行
* 需求 —— 打印5遍 `hello world`
* 思考 —— 如果要求打印100遍怎么办？

#### 2.1 while语句基本语法

```
初始条件设置 —— 通常是重复执行的 计数器
while 条件（判断 计数器 是否达到 目标次数）:
	条件满足时，执行的语句1
	条件满足时，执行的语句2
	条件满足时，执行的语句3
	...(省略)...
	
	处理条件(计数器 + 1)
```

**注意：**

* `while` 语句以及缩进部分时一个 **完整的代码块**

**lesson 147 第一个while循环**

**第一个while循环**

**需求**

* 打印5遍 Hello Python

```python
# 打印5遍 hello python
# 定义重复次数计数器
i = 1

# 使用while 判断条件
while i <= 5:
    # 循环内执行的代码
    print("hello python")
    # 处理计数器
    i += 1
print("循环结束后的 i = %d" % i)
```

> ***注意：循环结束后，之前定义的计数器条件的数值是依然存在的***

**lesson 148 单步调试while循环**

>  ***单步调试，跳出时计数器的值为6***

![image-20201109101804866](/Users/derek/Library/Application Support/typora-user-images/image-20201109101804866.png)



**lesson 149 死循环的概念和解决方法**

**死循环**

> *由于程序员的原因，**忘记** 在循环内部 **修改循环的判断条件** ，导致循环持续执行，程序无法终止！*

**lesson 150 赋值运算符**

#### 2.2 赋值运算符

* 在Python中，使用 `=` 可以给变量赋值
* 在算术运算时，为了简化代码的编写，Python还提供了一系列的 与 **算术运算符** 对应的 **赋值运算符**
* 注意：**赋值运算符中间不能使用空格**

| **运算符** | **描述**               | **实例**                           |
| :--------: | ---------------------- | ---------------------------------- |
|     =      | 简单的赋值运算符       | c = a +b 将 a + b的运算结果赋值给c |
|     +=     | 加法赋值运算符         | c += a 等效于 c = c + a            |
|     -=     | 减法赋值运算符         | c -=a 等效于 c = c - a             |
|     *=     | 乘法赋值运算符         | c *=a 等效于 c = c * a             |
|     /=     | 除法赋值运算符         | c /= a 等效于 c = c / a            |
|    //=     | 取整除赋值运算符       | c //= a 等效于 c = c // a          |
|     %=     | 取模（余数）赋值运算符 | c %= a 等效于 c = c % a            |
|    **=     | 幂赋值运算符           | c \*\*= a 等效于 c = c \*\* a      |



**lesson 151 程序计数从0开始**

#### 2.3 Python 中的计数方法

常见的计数方法有两种，可以分别称为：

* **自然计数法** （从1开始） —— 更符合人类的习惯
* **程序计数法** （从0开始） —— 几乎所有的程序语言都选择从0开始计数

因此，大家在编写程序时，应该尽量养成习惯：**除非需求的特殊要求，否则 循环 的计数都从 0 开始**



**lesson 152 循环计算思路分析**

#### 2.4 循环计算

> 在程序开发中，通常会遇到 **利用循环** **重复计算** 的需求

遇到这种需求，可以：

1. 在`while` 上方定义一个变量，用于存放**最终的计算结果**
2. 在循环体内部，每次循环都用 **最新的计算结果** **更新** 之前定义的变量

**需求**

* 计算 0～100 之间所有数字的累计求和结果

**lesson 153 0到100数字累加**

代码如下：

```python
# 计算 0～100 之间所有数字的累计求和结果

# 定义最终结果的变量
result = 0
# 定义整数变量记录循环次数
i = 0

# 开始循环
while i <= 100:
    # 每一次循环，都让result 这个变量和i这个变量计数器相加
    result = result + i

    # 处理计数器
    i += 1

print("0～%d 之间的数字求和结果 = %d" % (i-1, result))
```

**lesson 154 偶数求和—准备偶数**

**需求进阶**

* 计算 0～100 之间的所有 **偶数** 的累计求和结果

开发步骤

1. 编写循环 **确认** 要计算的数字
2. 添加 **结果** 变量，在循环内部 **处理计算结果**

**lesson 155 偶数求和—计算结果**

```python
# 1. 编写循环 确认 要计算的数字
# 2. 添加 结果 变量，在循环内部 处理计算结果


# 定义最终结果的变量
result = 0
# 定义整数变量记录循环次数
i = 0


# 开始循环
while i <= 100:
    # 判断变量i中的数值，是否是偶数
    if i % 2 == 0:
        print(i)
        # 每一次循环，都让result 这个变量和i这个变量计数器相加
        result = result + i

    # 处理计数器
    i += 1

print("0～%d 之间的偶数求和结果 = %d" % (i-1, result))
```

**lesson 156 break关键字的应用场景**

### 03. break 和 continue

> *`break` 和 `continue` 是专门在循环中使用的关键字*

* `break` **某一条件满足时** ， 退出循环，不再执行后续重复代码
* `continue` **某一条件满足时** ， 不执行后续重复的代码

> *`break` 和 `continue` 只针对 **当前所在的循环** 有效*

![image-20201109112852843](/Users/derek/Library/Application Support/typora-user-images/image-20201109112852843.png)



**lesson 157 break代码演练**

#### 3.1 `break`

* 示例代码：

```python
i = 0
while i < 10:
    # break 某一条件满足时，退出循环，不再执行后续重复的代码
    if i == 3:
        break
    print(i)
    i += 1

print("over")
```

**lesson 158 continue关键字应用场景**

只讲解

**lesson 159 continue代码演练**

#### 3.2 continue

*  示例代码：

```python
i = 0
while i < 10:
    # continue 某一条件满足时，不执行后续重复的代码
    if i == 3:
        # 使用continue，需要确认循环的计数是否修改，否则导致死循环
        i += 1
        continue
    print(i)
    i += 1

print("over")
```

* 需要注意：使用`continue`时，**条件处理部分的代码**

> *`continue`只针对当前所在循环有效*

**lesson 160 循环嵌套基本语法**

### 04. 循环嵌套

#### 4.1 循环嵌套

* `while` 嵌套就是： `while` 里面还有 `while`

```python
while 条件 1:
	条件满足时，做的事情1
	条件满足时，做的事情2
	条件满足时，做的事情3
	...(省略)...
	while 条件 2:
		条件满足时，做的事情1
		条件满足时，做的事情2
		条件满足时，做的事情3
		...(省略)...
		
		处理条件 2

	处理条件 1
```



**lesson 161 使用字符串运算直接输出**

#### 4.2 循环嵌套演练 —— 九九乘法表

##### 第1步：用嵌套打印小星星

**需求**

* 在控制台连续输出5行`*`, 每一行星号的数量依次递增

```
*
**
***
****
*****
```

* 使用字符串`*`打印

```python
# 在控制台连续输出5行`*`, 每一行星号的数量依次递增
# 由于用到行号，从数字1开始比较方便
row = 1
while row <= 5:
    print("*" * row)
    row += 1
```



**lesson 162 print函数的结尾处理**

##### 第2步：使用循环嵌套打印星号

**知识点** 对 `print` 函数的使用做一个增强

* 在默认情况下，`print` 函数输出内容后，会自动在内容末尾增加换行

* 如果不希望末尾增加换行，可以在 `print` 函数输出内容后面增减， `end = ""`

* 其中 `""` 中间可以指定 `print`函数输出内容后，继续希望显示的内容

* 语法格式如下：

```
# 向控制台输出内容结束后，不会换行
print("*", end = "")
# 单纯的换行
print("")
```

> end = "" 表示向控制台输出内容结束之后，不会换行

假设 Python **没有提供** 字符串的 `*` 操作 拼接字符串

**lesson 163 输出行并且确定思路**

**需求**

* 在控制台连接输出五行 `*` ，每一行星号的数量依次递增

```
*
**
***
****
*****
```

**开发步骤**

* 1> 完成5行内容的简单输出
* 2> 分析每行内部的 `*` 应该如果处理

**lesson 164 嵌套循环完成案例**

* 每行显示的星号和当前所在的行数是一致的
* 嵌套一个小的循环，专门处理每一行中 **列** 的星号显示

代码如下：

```python
row = 1
while row <= 5:
    # 每一行要打印的星号就是和当前的行数是一致的
    # 增加一个小的循环，专门负责当前行中，每一列的星号显示
    # 定义列的计数器
    col = 1
    while col <= row:
        print("*", end="")
        col += 1
    print("")
    row += 1
```

**lesson 165 九九乘法表1**

##### 第3步：九九乘法表

**需求**

输出九九乘法表，格式如下：
```
1 * 1 = 1 
1 * 2 = 2 2 * 2 = 4 
1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 
1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 
1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 
1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 
1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 
1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 
1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 
```
**开发步骤**

1. 打印9行星号
2. 将每一个`*`替换成对应的行与列相

**lesson 166 九九乘法表2**

```python
row = 1
while row <= 9:
    # 每一行要打印的星号就是和当前的行数是一致的
    # 增加一个小的循环，专门负责当前行中，每一列的星号显示
    # 定义列的计数器
    col = 1
    while col <= row:
        print("*", end="")
        col += 1
    print("")
    row += 1
```

**lesson 167 九九乘法表3**

```python
row = 1
while row <= 9:
    col = 1
    while col <= row:
        print("%d * %d = %d" %
              (col, row, col * row), end=" ")
        col += 1
    print("")
    row += 1
```

**lesson 168 九九乘法表4**

**问题**：

垂直方向上没有对齐

**解决方案：转义字符**

```
(col, row, col * row), end="\t")
```



**字符串中的转义字符 （扩展）**

* `\t` 在控制台输出一个 **制表符** ，协助在输出文本时，**垂直方向** 保持对齐
* `\n` 在控制台输出一个 **换行符**

> **制表符** *的功能是在不使用表格的情况下在 **垂直方向** 按列对齐文本*

| 转义字符 | 描述       |
| :------: | ---------- |
|   \\\    | 反斜杠符号 |
|   \\'    | 单引号     |
|   \\"    | 双引号     |
|    \n    | 换行       |
|    \t    | 横向制表符 |
|    \r    | 回车       |

```python
# * `\t` 在控制台输出一个 **制表符** ，协助在输出文本时，**垂直方向** 保持对齐
print("1\t2\t3")
print("10\t20\t30")

# * `\n` 在控制台输出一个 **换行符**
print("hello\nworld")

# \" 可以在控制台输出"
print("hello \" world")
```

显示结果：

```
1	2	3
10	20	30
hello
world
hello " world
```



**lesson 169 明确函数学习目标**

## 函数基础

**目标**

* 函数的快速体验
* 函数的基本使用
* 函数的参数
* 函数的返回值
* 函数的嵌套调用
* 在模块中定义函数

### 01. 函数的快速体验

#### 1.1 快速体验

* 所谓 **函数** ，就是把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
* 函数的使用包含两个步骤
  1. 定义函数 —— **封装** 独立的功能
  2. 调用函数 —— 享受 **封装** 的成果
* **函数的作用** ，在开发程序时，使用函数可以提高编写的效率以及代码的 **重用**

**演练步骤**

1. 新建 `04_函数` 项目
2. 复制之前完成的 **乘法表** 文件
3. 修改文件，增加函数定义 `multiple_table():`
4. 新建另外一个文件，使用 `import` 导入并且调用函数

**lesson 170 函数的概念及作用**

同上

**lesson 171 函数的快速体验**

```python
import hm_01_九九乘法表
hm_01_九九乘法表.multiple_table()
```

**lesson 172 函数的定义语法**

### 02. 函数基本使用

#### 2.1 函数的定义

定义函数的格式如下：

```
def 函数名():
	函数封装的代码
	......
```

1. `def` 是英文 define 的缩写
2. **函数名称** 应该能够表达 **函数封装代码** 的功能，方便后续的调用
3. **函数名称** 的命名应该 **符合 标识符的命名规则**
   * 可以由 **字母、下划线和数字** 组成
   * **不能以数字开头**
   * **不能与关键字重名**

#### 2.2 函数调用

调用函数很简单，通过 `函数名()` 即可完成对函数的调用

**lesson 173 第一个函数的演练**

#### 2.3 第一个函数演练

**需求**

1. 编写一个打招呼 `say_hello` 的函数，封装三行打招呼的代码
2. 在函数下方调用打招呼的代码

```python
name = "小明"


def say_hello():
    print("hello1")
    print("hello2")
    print("hello3")


print(name)

say_hello()

print(name)
```

> ***用 单步执行 F8 和 F7 观察以下代码的执行过程***

* 定义好函数以后，只表示这个函数封装了一段代码而已
* 如果不主动调用函数，函数是不会主动执行的

**lesson 174 函数的定义以及路线图**

第一个函数改造.py

**lesson 175 先定义函数再调用**

**思考**

* 能否将 **函数的调用** 放在 **函数定义** 的上方？
  * 不能
  * 因为在 **使用函数名** 调用函数之前，必须要保证 Python 已经知道函数的存在
  * 否则控制台会提示 `NameError : name 'say_hello' is not defined`(**名称错误：say_hello 这个名字没有被定义**)

**lesson 176 单步越过和单步进入**

#### 2.4 PyCharm 的调试工具

* **F8 Step Over** 可以执行单步执行代码，会把函数调用看作是一行代码直接执行
* **F7 Step Into** 可以单步执行代码，如果是函数，会进入函数内部

**lesson 177 函数的文档注释**

#### 2.5 函数的文档注释

* 在开发中，如果希望给函数添加注释，应该在 **函数定义** 的下方，使用 **连续的三对引号**
* 在 **连续的三对引号** 之间编写对函数的说明文字
* 在 **函数调用** 位置，使用快捷键 `Ctrl + Q` 可以查看函数的说明信息
* **备注：mac版本快捷键为 `^J`** ，另外需要选中函数后才有弹窗提示

> *注意：因为 **函数体相对比较独立**，**函数定义的上方**，应该和其他代码（包括注释）保留*
>
> ***两个空格***

**lesson 178 没有参数的函数**

### 03. 函数的参数

**演练需求**

1. 开发一个 `sum_2_num` 的函数
2. 函数能够实现 **两个数字的求和** 功能

演练代码如下：

```python
def sum_2_num():
    """对两个数字的求和"""
    num1 = 10
    num2 = 20
    result = num1 + num2
    print("%d + %d = %d" % (num1, num2, result))


sum_2_num()
```

**思考一下存在什么问题**

> 函数只能处理 **固定数值** 的相加

**如何解决**？

* 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了

#### 3.1 函数参数的使用

* 在函数名的后面的小括号内部填写 **参数**
* 多个参数之间使用 `, ` 分隔

```python
def sum_2_num(num1, num2):
    """对两个数字的求和"""
    result = num1 + num2
    print("%d + %d = %d" % (num1, num2, result))


sum_2_num(50, 20)
```

**lesson 179 参数的使用以及作用**

#### 3.2 参数的作用

*  **函数**，把 **具有独立功能的代码块** 组织成一个小模块，在需要的时候 **调用**
* **函数的参数**，增加函数的 **通用性** ，针对 **相同的数据处理逻辑**，能够 **适应更多的数据**
  1. 在函数 **内部**，把参数当作 **变量** 使用，进行需要的数据处理
  2. 函数调用时，按照函数定义的 **参数顺序**，把 **希望在函数内部处理的数据** ，**通过参数** 传递

**lesson 180 形参和实参**

#### 3.3 形参和实参

* **形参**： **定义** 函数时，小括号中的参数，是用来接收参数用的，在函数内部 **作为变量使用**
* **实参**：**调用** 函数时，小括号中的参数，是用来把数据传递到 **函数内部** 用的

**lesson 181 返回值的应用场景和格式**

### 04. 函数的返回值

* 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果，** 以便调用者针对具体的结果做后续的处理
* **返回值** 是函数 **完成工作** 后，**最后** 给调用者的 **一个结果**
* 在函数中使用 `return` 关键字可以返回结果
* 调用函数一方，可以 **使用变量** 来 接收 **函数** 的返回结果

> 注意： `return` 表示返回，后续的代码都不会被执行

```python
def sum_2_num(num1, num2):
    """对两个数字的求和"""
    return num1 + num2
  
result = sum_2_num(10, 20)
print("计算结果是：%d" % result)
```

**lesson 182 改造求和函数**

上节的代码实现

**lesson 183 retrun关键字的注意事项**

* `return`表示返回，下方的代码不会被执行

**lesson 184 函数嵌套调用执行路线图**

### 05. 函数的嵌套调用

* 一个函数里面 **又调用** 了 **另外一个函数**，这就是 **函数的嵌套调用**
* 如果函数 `test2` 中调用函数 `test1` 
  * 那么执行到调用 `test1` 函数时，会先把函数 `test1` 中的任务都执行完
  * 才会回到`test2`的位置，继续执行后续代码

```python
def test1():
    print("*" * 50)

def test2():
    print("-" * 50)
    test1()
    print("+" * 50)

test2()
```
**lesson 185 百度网站举例说明**

**lesson 186 参数增加分割线的灵活度**

#### **函数嵌套演练 —— 打印分隔线**

> 体会一下工作中 **需求是多变的**

**需求1**

* 定义一个 `print_line` 函数能够打印 `*` 组成的一条分隔线

```python
def print_line():
  print("*" * 50)
```

**需求2**

* 定义一个函数能够打印 **由任意字符组成** 的分隔线

```python
def print_line(chr):
  print(chr * 50)
```

**需求3**

* 定义一个函数能够打印 **任意重复次数** 的分隔线

```python
def print_line(chr, times):
  print(chr * times)
```

**lesson 187 打印多条分割线**

**需求4**

* 定义一个函数能够打印 **5**行 的分隔线，分隔线要求符合 **需求3**

> 提示：工作中针对需求的变化，应该冷静思考，**不要轻易修改之前已经完成的，能够正常执行的函数**

**lesson 188 增加多行分割线函数参数**

代码如下：

```python
def print_line(chr, times):
    """打印多行分隔线"""
    print(chr * times)
    

def print_lines(char, times):
    row = 0
    while row < 5:
        print_line(char, times)
        row += 1


print_lines("+", 50)
```

**lesson 189 PyCharm函数增加文档注释**

```python
def print_line(chr, times):
    """
    打印多行分隔线
    :param chr: 分隔线使用的分隔字符
    :param times: 分隔线重复的次数
    """
    print(chr * times)
```

* **PyCharm（mac版）中显示效果如下**：

![image-20201111104457371](/Users/derek/Library/Application Support/typora-user-images/image-20201111104457371.png)

**lesson 190 模块概念介绍**

### 06. 使用模块中的函数

> ***模块是Python 程序架构的一个核心概念***

* **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
* 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
* 在模块中定义的 **全局变量** 、**函数** 都是模块能够提供给外界直接使用的工具

#### 6.1 第一个模块体验

**步骤**

* 新建 `hm_10_分隔线模块.py`
  * 复制 `hm_09_打印多条分隔线.py` 中的内容，**最后一行 `print` 代码除外**
  * 增加一个字符串变量

```
name = "黑马程序员"
```

* 新建`hm_10_分隔线模块.py`文件，并且编写以下代码：

```python
import hm_10_分隔线模块

hm_10_分隔线模块.print_line("-", 80)
print(hm__10_分隔线模块.name)
```


**lesson 191 使用模块演练**

**体验小结**

* 可以 **在一个python文件** 中 **定义** **变量** **或者** **函数**
* 然后在 **另一个文件中** 使用 `import` 导入这个模块
* 导入之后，就可以使用 `模块名.变量/模块名.函数` 的方式，使用这个模块中定义的变量或者函数

> ***模块可以让曾经编写过的代码 方便的被复用***

**lesson 192 模块名也是一个标识符**

#### 6.2 模块名也是一个标识符
* 标识符可以由 **字母、下划线 和 数字**组成
* **不能以数字开头**
* **不能与关键字重名**

> *注意：如果再给Python 文件起名时， **以数字开头** 是无法在 `Pycharm` 中通过导入这个模块的*

**lesson 193 pyc文件提高程序执行速度**

#### 6.3 Pyc文件（了解）

> *C 是 compiled **编译过** 的意思*

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__` 的目录
2. 目录下会有一个 `hm_10_分隔线模块.cpython-35.pyc`的文件，`cpython-35` 表示 Python 解释器的版本
3. 这个 `pyc` 文件是由Python 解释器将 **模块的源码** 转换为 **字节码**
   * Python 这样保存 **字节码** 是作为一种启动 **速度的优化**

**字节码**

* Python 在解释源程序时是分为两个步骤的
  1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
  2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**
* 有了模块的字节码之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，python将会加载 .pyc 文件并跳过编译这个步骤
* 当 Python **重编译** 时，它会自动检查源文件和字节码文件的时间戳
* 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

> *提示： 有关模块以及模块的其他导入方式，后续课程还会逐渐展开*
>
> ***模块是Python程序架构的一个核心概念***

**lesson 194 高级变量学习目标**

## 高级变量类型

**目标**

* 列表
* 元组
* 字典
* 字符串
* 公共方法
* 变量高级

### **知识点回顾**

* Python 中数据类型可以分为 **数字型** 和 **非数字型**
* 数字型
  * 整型（int）
  * 浮点型（float）
  * 布尔型（bool）
    * **真** `True` `非0数` —— **非零即真**
    * **假** `False` `0`
  * 复数型（complex）
    * 主要用于科学计算，例如：平面场问题、波动问题、电感电容问题
* 非数字型
  * 字符串
  * 列表
  * 元组
  * 字典
* 在Python中，所有 **非数字型变量** 都支持以下特点：
  1. 都是一个 **序列** `sequence`,也可以理解为 **容器**
  2. 取值 `[]`
  3. 遍历 `for in`
  4. **计算长度**、**最大/最小值**、**比较**、**删除**
  5. **链接** `+` 和 **重复** `*`
  6. **切片**

**lesson 195 列表作用和定义方式**

### 01. 列表

#### 1.1 列表的定义

* `List` (列表) 是 Python中使用 **最频繁** 的数据类型，在其他语言中通常叫做 **数组**
* 专门用于存储 **一串 信息**
* 列表用 `[]` 定义，**数据** 之间使用 `,` 分隔
  * **索引** 就是数据在 **列表** 中的位置变好， **索引** 又可以被称为 **下标**

> *注意：从列表中取值时，如果 **超出索引范围** ，程序会报错*

```python
name_list = ["zhangsan", "lisi", "wangwu"]
```

lesson 196 存储数据方式以及取值

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201112092716320.png" alt="image-20201112092716320" style="zoom:68%;" />

**lesson 197 确认列表常用操作方法**

#### 1.2 列表常用操作

* 在IPython3 中定义一个 **列表**，例如：`lst`
* 输入 `lst` 按下 `TAB`键，IPython 会提示 **列表** 能够使用的 **方法** 如下：

```
In [8]: lst.clear
             append() count    insert   reverse
             clear    extend   pop      sort
             copy     index    remove
             <unknown>
```

| 序号 | 分类 | 关键字/函数/方法          | 说明                     |
| ---- | ---- | ------------------------- | ------------------------ |
| 1    | 增加 | 列表.insert(索引,数据)    | 在指定位置插入数据       |
|      |      | 列表.append(数据)         | 在末尾追加数据           |
|      |      | 列表.extend(列表2)        | 将列表2的数据追加到列表  |
| 2    | 修改 | 列表[索引] = 数据         | 修改指定索引的数据       |
| 3    | 删除 | del 列表[索引]            | 删除指定索引的数据       |
|      |      | 列表.remove[数据]         | 删除第一个出现的指定数据 |
|      |      | 列表.pop                  | 删除末尾数据             |
|      |      | 列表.pop(索引)            | 删除指定索引的数据       |
|      ||列表.clear|清空列表|
| 4    | 统计 | len(列表)                 | 列表长度                 |
|      |      | 列表.count(数据)          | 数据在列表中出现的次数   |
| 5    | 排序 | 列表.sort()               | 生序排序                 |
|      |      | 列表.sort(reverse = True) | 降序排序                 |
|      |      | 列表.reverse()            | 逆序、反转               |

**lesson 198 从列表中取值和取索引**

```python
name_list = ["zhangsan", "lisi", "wangwu"]
```

##### 取值和取索引

```python
# list index out range —— 列表索引超出范围
print(name_list[0])
# 使用index方法需要注意，传递的数据不在列表中，程序报错
print(name_list.index("lisi"))
```

**lesson 199 列表中修改指定位置数据**
##### 修改指定位置数据

```python
name_list[1] = "李四"
# IndexError: list assignment index out of range
# 列表指定的索引超出范围就会报错
# name_list[3] = "wangxiaoer"
```

**lesson 200 向列表增加数据**

##### 增加数据

```python
# append 方法可以向列表的末尾追加数据
name_list.append("王小二")
# insert方法可以在列表的指定索引位置插入数据
name_list.insert(1, "小美")
# extend 可以把其他列表追加到列表的末尾
temp_lst = ["孙悟空", "猪八戒", "沙师弟"]
name_list.extend(temp_lst)
```

**lesson 201 从列表删除数据**

##### 删除数据

```python
# remove 方法可以从列表中删除指定数据
name_list.remove("wangwu")
# pop方法默认可以把列表中最后一个元素删除
name_list.pop()
# pop方法可以指定要删除元素的索引
name_list.pop(3)
# clear方法可以清空整个列表
name_list.clear()
```

**lesson 202 使用del关键字删除数据**

##### del关键字删除数据

>  *del关键字本质上是用来从内存中删除一个变量的，如果使用，后续的代码就不能再使用这个变量了*

```python
name_list = ["张三", "李四", "王五"]

# 使用 del关键字 删除列表元素
# 建议使用列表方法，pop或者remove
del name_list[1]
```

**lesson 203 列表统计及删除方法扩展**

```python
name_list = ["张三", "李四", "王五", "张三"]

# len(lenth 长度) 函数可以统计列表中元素的总数
lst_len = len(name_list)
print("列表长度：%d" % lst_len)

# count 方法可以统计列表中某一个数据出现的次数
count = name_list.count("张三")
print("张三出现了 %d 次" % count)

# 从列表中删除首次出现的匹配数据
name_list.remove("张三")
```

**lesson 204 列表的排序和反转**

```python
name_list = ["zhangsan", "lisi", "wangwu", "wangxiaoer"]
num_list = [6, 8, 4, 1, 10]


# 升序
name_list.sort()
num_list.sort()
# 降序
name_list.sort(reverse=True)
num_list.sort(reverse=True)
# 逆序（反转）
name_list.reverse()
num_list.reverse()
```

**lesson 205 关键字、函数和方法**

##### 关键字、函数和方法（科普）

* 关键字是 Python内置的、具有特殊意义的标识符

```
In [1]: import keyword

In [2]: print(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

In [3]: len(keyword.kwlist)
Out[3]: 35
```

> ***关键字后面不需要使用括号***

* **函数** 封装了独立功能，可以直接调用

```
函数名(参数)
```

> ***函数需要死记硬背***

* **方法** 和函数类似，同样是封装了独立的功能
* **方法** 需要通过 **对象** 来调用，表示针对这个 **对象** 要做的操作

```
对象.方法名()
```

> ***在变量后面输入 `.` , 然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多***

**lesson 206 列表迭代遍历**

#### 1.3 列表的循环遍历 —— for

* **遍历** 就是 **从头到尾 依次** 从 **列表** 中获取数据
  * 在 **循环体内部** 针对 **每一个元素** ，执行相同的操作
* 在 Python 中为了提高列表的遍历效率，专门提供的 **迭代 iteration 遍历**
* 使用 `for` 就能够实现迭代

```python
# for 循环内部使用的变量 in 列表
for name in name_list:
	# 循环内部针对列表元素进行的操作
	print(name)
```

**lesson 207 列表的应用场景**

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201112154929911.png" alt="image-20201112154929911" style="zoom:67%;" />

#### 1.4 应用场景

* 尽管 Python 的 **列表** 中可以 **存储不同类型的数据**
* 但是在开发中，更多的应用场景是：
  1. **列表** 存储相同类型的数据
  2. 通过 **迭代遍历**，在循环体内部，针对列表中的每一项元素，执行相同的操作

**lesson 208 元组特点和列表的区别**

### 02. 元组

#### 2.1 元组的定义

* `Tuple` (元组) 与列表类似，不同之处在于元组的 **元素不能修改**
  * **元组** 表示多个元素组成的序列
  * **元组** 在 Python 开发中，有特定的应用场景
* 用于存储 **一串信息，数据** 之间使用`,`分隔
* 元组用 `()`定义
* 元组的 **索引** 从 `0` 开始
  * **索引** 就是数据在 **元组** 中的位置编号

```
info_tuple = ("zhangsan", 18, 1.75)
```

**创建空元组**

```python
info_tuple = ()
```

**元组中 只包含一个元素时，需要 在元素后面添加逗号**

```python
info_tuple = (50,)
```



**lesson 209 元组变量的定义**

同上节

**lesson 210 元组变量的常用操作**

#### 2.2 元组常用操作

* 在 `Ipython3`中定一个 **元组**，例如：`info = ()`
* 输入 `info.`后按下 `TAB`键，ipython 会提示 **元组** 能够使用的函数如下：

```
info.count info.index
```

> *有关 **元组** 的 **常用操作** 可以参照上图练习*



```python
info_tuple = ("zhangsan", 18, 1.75, "zhangsan")

# 取值和索引
print(info_tuple[0])
# 已经知道数据的内容，希望知道数据的索引
print(info_tuple.index(1.75))

# 统计计数
count = info_tuple.count("zhangsan")
print(count)

# 统计元组中包含的元素个数
print(len(info_tuple))
```

**lesson 211 元组变量的循环遍历**

#### 2.3 循环遍历

* **取值** 就是从 **元组** 中获取存储在指定位置的数据
* **遍历** 就是 **从头到尾** 依次 从 **元组** 中获取数据

```python
#  for 循环内部使用的变量 in 元组
for item in info:
  #  循环内部针对元组元素进行的操作
     print(item)
```

> * 在 Python 中，可以使用 `for` 循环遍历所有非数字型类型的变量： **列表** 、**元组**、**字典** 以及 **字符串**
> * 提示：在实际开发中，除非 **能够确认元组中的数据类型**，否则针对元组的循环遍历需求并不是很多

**lesson 212 元组的应用场景**

#### 2.4 应用场景

* 尽管可以使用 `for in` 遍历 **元组**
* 但是在开发中，更多的应用场景是：
  * **函数的 参数 和 返回值**，一个函数可以接收 **任意多个参数**，或者 **一次返回多个数据**
    * 有关 **函数的参数 和 返回值** ，在后续 **函数高级** 中具体说明
  * **格式字符串**，格式话字符串后面的 `()` 本质上就是一个元组
  * **让列表不可以被修改**，以保护数据安全

```python
info = ("zhangsan", 18)
print("%s 的年龄是 %d" % info)
```

**lesson 213 元组和格式化字符串**

```python 
info_tuple = ("xiaoming", 21, 1.85)
# 格式化字符串后面的 () 本质上就是元组
print("%s 年龄是 %d，身高是 %.2f" % (info_tuple))
```

**lesson 214 元组和列表之间的转换**

**元组和列表之间的转换**

* 使用`list`函数可以把元组转换成列表

```python
list(元组)
```

* 使用 `tuple` 函数可以把列表转换成元组

```python
tuple(列表)
```

**lesson 215 字典格式以及键值对概念**

### 03. 字典

#### 3.1 字典的定义

* `dictionary(字典)`是 **除列表外** Python 之中 **最灵活** 的数据类型
* 字典同样可以用来 **存储多个数据**
  * 通常用于存储 **描述一个** `物体` 的相关信息

* 和列表的区别
  * **列表** 是 **有序** 的对象集合
  * **字典** 是 **无序** 的对象集合
* 字典用`{}`定义
* 字典使用 **键值对** 存储数据，键值对之间使用 `,` 分隔
  * **键** `key` 是索引
  * **值** `value` 是数据
  * **键** 和 **值** 之间使用 `:` 分隔
  * **键必须是唯一的**
  * **值** 可以取任何数据类型，但 **键** 只能使用 **字符串、数字** 或 **元组**

```python
xiaoming = {"name": "小明"，
						"age": 18
						"gender": True
						"height": 1.75
}
```

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201113145103277.png" alt="image-20201113145103277" style="zoom: 80%;" />![image-20201113145153325](/Users/derek/Library/Application Support/typora-user-images/image-20201113145153325.png)





<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201113145227798.png" alt="image-20201113145227798" style="zoom:80%;" />

**lesson 216 字典定义以及应用场景**

* 字典的定义
* 代码如下：

```python
# 字典无序集合，输出顺序和定义时不一定一致
xiaoming = {"name":"小明",
            "age":18,
            "gender": True,
            "height": 1.75,
            "weight": 75.5
}

print(xiaoming)
```

**lesson 217 字典的增删改查常用操作**

* 字典的常用操作

```python
xiaoming_dict = {"name": "小明"}


# 取值
print(xiaoming_dict["name"])

# 增加/修改
# 如果key不存在，会新增键值对
xiaoming_dict["age"] = 18
# 如果key存在，会修改已经存在的键值对
xiaoming_dict["name"] = "小小明"

# 删除
# 删除指定键值对时，指定的key不存在，程序报错
xiaoming_dict.pop("name")

print(xiaoming_dict)
```

**lesson 218 字典的统计、合并、清空**



#### 3.2 字典常用操作

* 在 ipython3 中定义一个 **字典**，例如：`xiaoming = {}`
* 输入 `xiaoming.`，按下 `TAB`键，python 会提示 **字典** 能够使用的函数如下：

```
In [15]: xiaoming.
                   clear()      get()        pop()        update()
                   copy()       items()      popitem()    values()
                   fromkeys()   keys()       setdefault()
```

> *有关 **字典** 的 **常用操作** 可以参照上图联系*
>

```python
xiaoming_dict = {"name": "小明",
                 "age": 18}

# 统计键值对的数量
print(len(xiaoming_dict))

# 合并字典
tmp_dict = {"height": 1.75,
            "age": 20}
# 注意：被合并字典中包含已存在的键值对时，会覆盖原有的键值对
xiaoming_dict.update(tmp_dict)

# 清空字典
xiaoming_dict.clear()

print(xiaoming_dict)
```

**lesson 219 字典的循环遍历**

#### 3.3 循环遍历

* **遍历** 就是 **依次** 从 **字典** 中获取所有键值对

```python
# for 循环内部使用的 `key 的变量` in 字典
for k in xiaoming:
  	
    print("%s: %s" % (k, xiaoming[k]))
```

> ***提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多***


**lesson 220 字典和列表组合应用场景**

#### 3.4 应用场景

* 尽管可以使用 `for in` 遍历 **字典**
* 但是在开发中，更多的应用场景是：
  * 使用 **多个键值对**，存储 **描述一个** **物体 ** **的相关信息** —— 描述更复杂的数据信息
  * 将 **多个字典** **放在一个列表** 中，再进行遍历，在循环体内部针对每一个字典进行 **相同的处理**

**lesson 221 字符串定义和基本使用**

### 04 字符串

#### 4.1 字符串的定义

* **字符串** 就是 **一串字符**，是编程语言中表示文本的数据类型
* 在 Python中可以使用 **一对双引号** `""`**或者一对单引号** `''`定义一个字符串
  * 虽然可以使用 `\"` 或者 `\'`做字符串的转义，但是在实际开发中：
    * 如果字符串内部需要使用`"`, 可以使用 `'`定义字符串
    * 如果字符串内部需要使用`'`, 可以使用 `"`定义字符串
  * 可以使用 **索引** 获取一个字符串中 **指定位置的字符**，索引计数从 **0** 开始
  * 也可以使用 `for` **循环遍历** 字符串中每一个字符

> 大多数编程语言都使用 `"` 来定义字符串

```python
string = "Hello Python"
for c in string：
	print(c)
```

![image-20201114183439595](/Users/derek/Library/Application Support/typora-user-images/image-20201114183439595.png)

**lesson 222 长度、计数和位置方法**

#### 4.2 字符串的常用操作

* 在 `ipython3` 中定义一个 **字符串**，例如： `hello_str=""`
* **输入** **`hello_str=""`**  按下 `TAB`键，ipython 会提示 **字符串** 能够使用的 **方法** 如下：

```python
In [1]: hello_str = ""

In [2]: hello_str.
 capitalize()   format_map()   isnumeric()    maketrans()    split()
 casefold()     index()        isprintable()  partition()    splitlines()
 center()       isalnum()      isspace()      replace()      startswith()
 count()        isalpha()      istitle()      rfind()        strip()
 encode()       isascii()      isupper()      rindex()       swapcase()
 endswith()     isdecimal()    join()         rjust()        title()
 expandtabs()   isdigit()      ljust()        rpartition()   translate()
 find()         isidentifier() lower()        rsplit()       upper()
 format()       islower()      lstrip()       rstrip()       zfill()
```

> ***提示：正是因为python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！***

**lesson 223 字符串常用方法和分类**

**1) 判断类型 -9**

| 方法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| string.isspace()   | 如果string 中只包含空格，则返回True                          |
| string.isalnum()   | 如果string 至少有一个字符并且所有字符都是字母或者数字则返回True |
| string.isalpha()   | 如果string 至少有一个字符并且所有字符都是字母则返回True      |
| string.isdecimal() | 如果string 只包含数字则返回True，全角数字                    |
| string.isdigit()   | 如果string 只包含数字则返回True，全角数字、(1)、\u00b2       |
| string.isnumeric() | 如果string 只包含数字则返回True，全角数字、汉字数字          |
| string.istitle()   | 如果string 是标题化的（每个单词的首字母大写）则返回 True     |
| string.islower()   | 如果string 中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回 True |
| string.isupper()   | 如果string 中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回 True |

**2) 查找和替换 -9**

| 方法                                                  | 说明                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| string.startswith(str)                                | 检查字符串是否以str开头，是则返回True                        |
| string.endswith(str)                                  | 检查字符串是否以str结束，是则返回True                        |
| string.find(str,start=0,end=len(string))              | 检测str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 |
| string.rfind(str,start=0,end=len(string))             | 类似find()函数，不过是从右边开始查找                         |
| string.index(str,start=0,end=len(string)              | 跟find()方法类似，只不过如果str不在string 会报错             |
| string.rindex(str,start=0,end=len(string)             | 类似index()，不过是从右边开始                                |
| string.replace(old_str,new_str,num=string.count(old)) | 把string 中的old_str 替换成 new_str,如果num指定，则替换不超过num次 |



**3) 大小写转换 -5**

| 方法                | 说明                           |
| ------------------- | ------------------------------ |
| string.capitalize() | 把字符串的第一个字符大写       |
| string.title()      | 把字符串的每个单词首字母大写   |
| string.lower()      | 转换string中所有大写字符为小写 |
| string.upper()      | 转换string中所有小写字母为大写 |
| string.swapcase()   | 反转string中的大小写           |

**4) 文本对齐 -3**

| 方法                 | 说明                                                        |
| -------------------- | ----------------------------------------------------------- |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度width的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度width的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度width的新字符串   |



**5) 去除空白字符 -3**

| 方法            | 说明                             |
| --------------- | -------------------------------- |
| string.istrip() | 截掉string左边（开始）的空白字符 |
| string.rstrip() | 截掉string右边（末尾）的空白字符 |
| string.strip()  | 截掉string 左右两边的空白字符    |



**6) 拆分和链接 -5**

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| string.partition(str)     | 把字符串 string 分成一个 3 元素的元组(str前面,str,str后面)   |
| string.rpartition(str)    | 类似partition()函数，不过从右边开始查找                      |
| string.split(str=" ",num) | 以str 为分隔符切片 string，如果num有指定值，则仅分隔num+1个子字符串，str默认包含'\r','\t','\n' 和空格 |
| string.splitlines()       | 按照行('\r','\t','\n')分隔，返回一个包含各行作为元素的列表   |
| string.join(seq)          | 以string作为分隔符，将seq中所有的元素（的字符串表示）合并为一个新的字符串 |

**lesson 224 判断空白字符**

```python
# 1. 判断空白字符
space_str = "    \t\n\r"
print(space_str.isspace())

# OutPut： True
```

**lesson 225 判断数字的三个方法**

```python
# 2. 判断字符串中只包含数字
# 以下三个方法都不能判断小数
# num_str = "1.1"
# num_str = "\u00b2"
num_str = "一千"
print(num_str)
print(num_str.isdecimal())
print(num_str.isdigit())
print(num_str.isnumeric())
```

**lesson 226 字符串的查找和替换**

```python
hello_str = "hello world"

# 1. 判断是否以指定字符串开始
print(hello_str.startswith("hello"))

# 2. 判断是否以指定字符串结束
print(hello_str.endswith("world"))

# 3. 查找字符串
# 类似index,查找指定的字符串在大字符串中的索引
# 如果查找的字符串不存在，find不会报错，而是返回 -1
print(hello_str.find("llo"))
print(hello_str.find("abc"))

# 4. 替换字符串
# replace 方法执行完成后，会返回一个新的字符串
# 注意：不会修改原字符串
print(hello_str.replace("world", "python"))
print(hello_str)
```

**lesson 227 文本对齐方法和演练**

```python
# 要求，顺序并且居中对齐输出
poem = ["登鹳雀楼",
        "王之涣",
        "白日依山尽",
        "黄河入海流",
        "欲穷千里目",
        "更上一层楼"
]

# 居中对齐
for poem_str in poem:
    print("|%s|" % poem_str.center(10, " "))

print("-" * 50)
# 向左对齐
for poem_str in poem:
    print("|%s|" % poem_str.ljust(10, " "))
```

**lesson 228 去除空白字符**
```python
for poem_str in poem:
    print("|%s|" % poem_str.strip().center(10, " "))
```
**lesson 229 拆分和拼接字符串**

```python
poem_str = "登鹳雀楼\t 王之涣 \t 白日依山尽 \t \n 黄河入海流 \t\t 欲穷千里目 \n \t 更上一层楼"

print(poem_str)

# 1. 拆分字符串
poem_list = poem_str.split()
print(poem_list)

# 2. 合并字符串
result = " ".join(poem_list)
print(result)
```

**lesson 230 切片概念和语法及索引**

#### 4.3 字符串的切片

* 切片 方法适用于 **字符串、列表、元组**
  * **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
  * **切片** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
  * **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

![image-20201115165941345](/Users/derek/Library/Application Support/typora-user-images/image-20201115165941345.png)

```
字符串[开始索引：结束索引：步长]
```

**注意：**

1. 指定的区间属于 **左闭右开** 型 `[开始索引,结束索引)`=> `开始索引 >= 范围 < 结束索引`
   * 从 **起始** 位置开始，到 **结束** **位的前一位** 结束 （**不包含结束位本身**）
2. 从头开始，**开始索引 数字可以省略，冒号不能省略**
3. 到末尾结束，**结束索引 数字可以省略，冒号不能省略**
4. 步长默认为 **1**，如果连续切片，**数字和冒号都可以省略**

**lesson 231 字符串切片演练**

```python
In [1]: num_str = "0123456789"

# 截取从2到5位置 的字符串
In [2]: num_str[2:6]
Out[2]: '2345'

# 截取从 2到末尾的字符串
In [3]: num_str[2:]
Out[3]: '23456789'
  
# 截取从开始 到 5 的字符串
In [5]: num_str[0:6]
Out[5]: '012345'
# 截取完整的字符串
In [6]: num_str[:]
Out[6]: '0123456789'
# 从开始位置，每隔一个字符截取字符串
In [8]: num_str[::2]
Out[8]: '02468'
# 从索引 1 开始，每隔一个取一个
In [9]: num_str[1::2]
Out[9]: '13579'
# 截取从2 到 末尾 -1 的字符串
In [11]: num_str[2:-1]
Out[11]: '2345678'
# 截取字符串末尾两个字符
In [12]: num_str[-2:]
Out[12]: '89'
# 字符串的逆序
In [13]: num_str[-1::-1]
Out[13]: '9876543210'

In [14]: num_str[::-1]
Out[14]: '9876543210'

```

**lesson 232 公共方法1**

### 05. 公共方法

#### 5.1 Python内置函数

Python 包含了以下内置函数：

| 函数      | 描述                                       | 备注                      |
| --------- | ------------------------------------------ | ------------------------- |
| len(item) | 计算容器中元素个数                         |                           |
| del(item) | 删除变量                                   | del有两种方式             |
| max(item) | 返回容器中元素最大值                       | 如果是字典，只针对key比较 |
| min(item) | 返回容器中元素最小值                       | 如果是字典，只针对key比较 |
| cmp(item) | 比价两个值，`-1 小于`| `0 相等`| `/1 大于` | Python 3.x 取消了 cmp函数 |

**注意**

* **字符串** 比较符合以下规则："0" < "A" < "a"

**lesson 233 公共方法2**

#### 5.2 切片

| 描述 | Python表达式       | 结果  | 支持的数据类型     |
| ---- | ------------------ | ----- | ------------------ |
| 切片 | “0123456789”[::-2] | 97531 | 字符串、列表、元组 |

* **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
* **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
* **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据，**不支持切片**

**lesson 234 公共方法3**

#### 5.3 运算符

|    运算符     | Python表达式      | 结果                      | 描述           | 支持的数据类型           |
| :-----------: | ----------------- | ------------------------- | -------------- | ------------------------ |
|       +       | [1,2] + [3,4]     | [1,2,3,4]                 | 合并           | 字符串、列表、元组       |
|       *       | ["Hi!"]*4         | ["Hi!","Hi!","Hi!","Hi!"] | 重复           | 字符串、列表、元组       |
|      in       | 3 in (1,2,3)      | True                      | 元素是否存在   | 字符串、列表、元组、字典 |
|    not in     | 4 not in (1,2,3)  | True                      | 元素是否不存在 | 字符串、列表、元组、字典 |
| \> >= == < <= | (1,2,3) < (2,2,3) | True                      | 元素比较       | 字符串、列表、元组       |

**lesson 235 公共方法4**

**注意**

* `in` 在对 **字典** 操作时，判断的是 **字典的键**
* `in` 和 `not in` 被称为 **成员运算符**

**成员运算符**

成员运算符用于 **测试** 序列中是否包含指定的 **成员**

| 运算符 | 描述                                                | 实例                        |
| ------ | --------------------------------------------------- | --------------------------- |
| in     | 如果在指定的序列中找到值返回True，否则返回False     | 3 in (1,2,3) 返回 True      |
| not in | 如果在指定的序列中没有找到值返回True，否则返回False | 3 not in (1,2,3) 返回 False |

注意：在对 **字典** 操作时，判断的是 **字典的键**

**lesson 236 公共方法5**

#### 5.4 完整的for循环语法

* 在 Python 中 完整的 **for 循环** 的语法如下：

```python
for 变量 in 集合：
		循环体代码
else:
		没有通过break退出循环，循环结束后，会执行的代码
```
**lesson 237 公共方法6**

**应用场景**

* 在 **迭代遍历** 嵌套的数据类型时，例如 **一个列表包含了多个字典**
* 需求：要判断 某一个字典中 是否存在 指定的 值
  * 如果 **存在**，提示并且退出循环
  * 如果 **不存在**，在 **循环整体结束** 后，希望 **得到一个统一的提示**

```python
students = [{"name": "阿土"},
            {"name": "小美"}]

find_name = "阿土"

for stu_dict in students:
    # print(stu_dict)
    if stu_dict["name"] == find_name:
        print("找到了 %s" % find_name)
        break
else:
    # 如果没有找到目标，还希望得到一个提示
    print("抱歉，没有找到 %s" % find_name)
print("循环结束")
```

**lesson 238 名片管理系统1**

## 综合应用 —— 名片管理系统

**目标**

综合应用已经学习过的知识点：

* **变量**
* **流程控制**
* **函数**
* **模块**

### 系统需求

* 1. 程序启动，先是名片管理系统欢迎界面，并显示功能菜单

``` 
*******************************************
欢迎使用 [名片管理系统] v1.0

1.新建名片
2.显示全部
3.查询名片

0.退出系统
*******************************************
```

* 2. 用户用数字选择不同的功能
* 3. 根据功能选择，执行不同的功能
* 4. 用户名片需要记录用户的 **姓名、电话、QQ、邮件**
* 5. 如果查询到指定的名片，用户可以选择 **修改** 或者 **删除** 名片

**步骤**

1. 框架搭建
2. 新增名片
3. 显示所有名片
4. 查询名片
5. 查询成功后修改、删除名片
6. 让Python程序能够直接运行

**lesson 239 名片管理系统2**

### 01. 框架搭建

**目标**

* 搭建名片管理系统 框架结构
  1. 准备文件，确定文件名，保证能够 **在需要的位置** 编写代码
  2. 编写 **主运行循环**，实现基本的 **用户输入和判断**

#### 1.1 文件准备

1. 新建 `card_main.py` 保存 **主程序功能代码**
   * 程序的入口
   * 每一次启动名片管理系统都通过 `main` 这个文件启动

2. 新建 `cards_tools.py` 保存 **所有名片功能函数**
   * 将对名片的 **新增、查询、修改、删除** 等功能封装在不同的函数中

#### 1.2 编写主运行循环

* 在 `cards_main` 中添加一个无限循环

**lesson 240 名片管理系统3**

```python
# 无限循环，由用户主动决定什么时候退出循环
while True:

    # 显示功能菜单

    action_str = input("请选择希望执行的操作：")
    print("您选择的操作是：【%s】" % action_str)

    # 1,2,3 针对名片的操作
    if action_str in ['1', '2', '3']:
        pass
    # 0 退出系统
    elif action_str == "0":
        print("欢迎再次使用【名片管理系统】")
        break
    # 其他内容输入错误，需要提示用户
    else:
        print("您输入的不正确，请重新选择")
```

**lesson 241 名片管理系统4**

* 使用 `if、elif、else`判断用户想执行的操作

**lesson 242 名片管理系统5**

* 增加`while True`无限循环，只有在用户输入 “0” 时，退出程序

**lesson 243 名片管理系统6**
* 增加嵌套 `if` 循环，判断用户具体执行的操作

```python
# 新增名片
if action_str == "1":
    print("新增名片")
# 显示名片
elif action_str == "2":
    pass
# 查询名片
elif action_str == "3":
    pass
```

lesson 244 名片管理系统7

**小结：**

**字符串判断**

```python
if action_str in ['1', '2', '3']:
```

```python
if action == "1" or action == "2" or action == "3":
```

1. 使用 `in` 针对 **列表** 判断，避免使用 `or` 拼接复杂的逻辑条件
2. 没有使用 `int` 转换用户输入，可以避免 **一旦用户输入的不是数字**，导致程序运行出错

**pass**

* `pass` 就是一个空语句，不做任何事情，一般用作占位语句
* 是为了保持程序结构的完整性

**无限循环**

* 在开发软件时，如果 **不希望程序执行后** 立即退出
* 可以在程序中增加一个 **无限循环**
* **由用户来决定** 退出程序的时机

**lesson 245 名片管理系统8**

##### TODO 注释

* 在 `#` 后跟上 `TODO`，用于标记需要去做的工作

```python
# TODO(作者/邮件) 显示系统菜单
```
**lesson 246 名片管理系统9**
* 开发显示欢迎界面&功能菜单
* `show_menu` 函数放在`cards_tools` 模块内，`cards_main`模块通过import导入后调用

```python
def show_menu():
    """显示菜单"""
    print("*" * 50)
    print("欢迎使用 【名片管理系统 v1.0】")
    print("")
    print("1. 新增名片")
    print("2. 显示全部")
    print("3. 搜索名片")
    print("")
    print("0. 退出系统")
    print("*" * 50)
```

**lesson 247 名片管理系统10**

* 在`cards_tools` 模块内部，为 **新增名片、显示全部、搜索名片**添加三个对应的函数：`new_card` `show_all` `search_card` ，在主模块中用函数替换`pass`占位符
* 暂时不实现函数的具体功能
* 框架搭建到此全部完成

```python
def new_card():
    """新增名片"""
    print("-" * 50)
    print("新增名片")


def show_all():
    """显示所有名片"""
    print("-" * 50)
    print("显示所有名片")


def search_card():
    print("-" * 50)
    print("搜索名片")
```

**lesson 248 名片管理系统11**

### 02. 保存名片数据的结构

**程序就是用来处理数据的，而变量就是用来存储数据的**

* 使用 **字典** 记录 **每一张名片** 的详细信息
* 使用 **列表** 统一记录所有的 **名片字典**

![image-20201124103618918](/Users/derek/Library/Application Support/typora-user-images/image-20201124103618918.png)



**定义名片列表变量**

* 在 `cards_tools` 文件的顶部增加一个 **列表变量**

```python
# 所有名片记录的列表
card_list = []
```

**注意**

1. **所有名片相关操作**，都需要使用这个列表，所以应该 **定义在程序的顶部**
2. **程序刚运行时，没有数据**，所以是 **空列表**

**lesson 249 名片管理系统12**

* 开发新增名片功能，函数 `new_cards`:

```python
def new_card():
    """新增名片"""
    print("-" * 50)
    print("新增名片")
    # 1. 提示用户输入名片的详细信息
    name = input("请输入姓名：")
    phone = input("请输入电话：")
    qq = input("请输入QQ：")
    email = input("请输入邮箱：")

    # 2. 使用用户输入的信息建立一个名片字典
    card_dict = {"name": name,
                 "phone": phone,
                 "QQ": qq,
                 "email": email}
    # 3. 将名片字典添加到列表中
    card_list.append(card_dict)
    print(card_list)
    # 4. 提示用户添加成功
    print("添加 %s 的名片成功" % name)
```

**lesson 250 名片管理系统13**

* 修改变量名增加 `_str`后缀，提高代码可读性
* 选中要修改的变量名，右键选择 `Refactor`,选择`Rename`,一次修改代码中所有变量的名称

**lesson 251 名片管理系统14**

* 实现`show_all`函数，视频缺失

**lesson 252 名片管理系统15**

* 判断名片列表为空，不打印表头
* 使用`return`关键字返回到函数调用的位置

**lesson 253 名片管理系统16**

* 开发查询名片的函数 `search_card` 

```python
def search_card():
    print("-" * 50)
    print("搜索名片")
    # 1. 提示用户输入要搜索的姓名
    find_name = input("请输入要查找的姓名：")
    # 2. 遍历名片列表，查询要搜索的姓名，如果没有找到，需要提示用户
    for card_dict in card_list:
        if card_dict["name"] == find_name:
            print("找到了")
            print("姓名\t\t电话\t\tQQ\t\t邮箱")
            print("=" * 50)
            print("%s\t\t%s\t\t%s\t\t%s" % (card_dict["name"],
                                            card_dict["phone"],
                                            card_dict["QQ"],
                                            card_dict["email"]))
            # TODO 针对找到的记录执行修改和删除的操作
            break
    else:
        print("没有找到：【%s】" % find_name)
```

**lesson 254 名片管理系统17**

* 开发函数 `deal_cards` 专门处理查找到名片的修改和删除

> ***这么做的好处是，不会导致单个函数中的代码过长，如果过长，将具体的功能拆分成一个一个单独的函数来处理，这样使得每个函数中的代码都不至于过长***

**lesson 255 名片管理系统18**

* 开发 `deal_cards`函数，对找到的名片进行处理

```python
def deal_cards(find_dict):
    print(find_dict)
    action_str = input("请选择要执行的操作： "
                       "[1] 修改 [2] 删除 [0] 返回上级菜单")
    if action_str == "1":
        print("修改名片")
    elif action_str == "2":
        print("删除名片")
```

**lesson 256 名片管理系统19**

* 实现 `deal_cards` 函数中，删除名片的操作

```python
elif action_str == "2":
    card_list.remove(find_dict)
    print("删除名片成功！")
```

**lesson 257 名片管理系统20**

* 实现 `deal_cards`函数中，修改名片的操作

```python
if action_str == "1":
    find_dict["name"] = input("姓名：")
    find_dict["phone"] = input("电话：")
    find_dict["QQ"] = input("QQ:")
    find_dict["email"] = input("邮箱：")
    print("修改名片成功！")
```

**lesson 258 名片管理系统21**

* 细化上一节中的修改名片功能，不修改仍需输入原来的内容
* 自定义输入函数 `input_card_info`

```python
def input_card_info(dict_value, tip_message):

    # 1. 提示用户输入内容

    # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果
    
    # 3. 如果用户没有输入内容，返回 `字典中原有的值`

    pass
```

**lesson 259 名片管理系统22**

* 实现上一节中自定义输入的函数 `input_card_info`
* 将 `deal_cards` 调用自定义输入函数 `input_card_info`

```python
def deal_cards(find_dict):
    print(find_dict)
    action_str = input("请选择要执行的操作： "
                       "[1] 修改 [2] 删除 [0] 返回上级菜单")
    if action_str == "1":
        find_dict["name"] = input_card_info(find_dict["name"], "姓名：")
        find_dict["phone"] = input_card_info(find_dict["phone"], "电话：")
        find_dict["QQ"] = input_card_info(find_dict["QQ"], "QQ:")
        find_dict["email"] = input_card_info(find_dict["email"], "邮箱：")
        print("修改名片成功！")
    elif action_str == "2":
        card_list.remove(find_dict)
        print("删除名片成功！")


def input_card_info(dict_value, tip_message):

    # 1. 提示用户输入内容
    result_str = input(tip_message)

    # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果
    if len(result_str) > 0:
        return result_str

    # 3. 如果用户没有输入内容，返回 `字典中原有的值`
    else:
        return dict_value
```

**lesson 260 名片管理系统23**

* 函数功能开发完成后，添加函数的文档注释
* 检查之前添加的 `TODO`注释

**lesson 261 名片管理系统24**

**lesson 262 变量的引用概**

### 03. LINUX上的Shebang符号(#!)

* `#!` 这个符号叫做 `Shebang`或者`She-bang`
* `Shebang`通常在 `Unix` 系统脚本中的 **第一行开头** 使用
* 指明 **执行这个脚本文件** 的 **解释程序**

**使用Shebang 的步骤**

* 1. 使用 `which` 查询 Python3 解释器所在的路径

```shell
$ which python3
```

* 2. 修改要运行的 **主Python文件**, 在第一行增加以下内容

```shell
#! /usr/bin/python3
```

* 3. 修改 **主python文件** 的文件权限，增加执行权限

```shell
$ chmod +x cards_main.py
```

* 4. 在需要时执行程序即可

```shell
$ ./card_main.py		
```



## 变量进阶（理解）

**目标**

* 变量的引用
* 可变和不可变类型
* 局部变量和全局变量

### 01. 变量的引用

> * *变量 和 数据 都是保存在 **内存** 中的*
> * *在 Python 中 **函数** **的 参数传递** 以及 **返回值** 都是靠 **引用** 传递的*

#### 1.1 引用的概念

在 Python 中

* **变量** 和 **数据** 是分开存储的
* **数据** 保存在内存中的一个位置
* **变量** 中保存着数据在内存中的地址
* **变量** 中 **记录数据的地址** ，就叫做 **引用**
* 使用 `id()` 函数可以查看变量中保存数据所在的 **内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用**
>
> * 变量 **不再** 对之前的数据引用
> * 变量 **改为** 对新赋值的数据引用

#### 1.2 变量引用 的示例

在 Python中，变量的名字类似于 **便签纸** 贴在 **数据** 上

* 定义一个整数变量 `a` ,并且赋值为 `1`

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201116212152246.png" style="zoom:80%;" />

* 将变量 `a` 赋值为 `2`

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201116212304466.png" alt="image-20201116212304466" style="zoom:80%;" />

* 定义一个整数变量 `b` ，并且将变量 `a` 的值赋值给 `b`

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201116212439745.png" alt="image-20201116212439745" style="zoom:80%;" />

> *变量 `b` 是第2个贴在数字 `2` 上的标签*

在 Python 中，函数的 **实参/返回值** 都是是靠 **引用** 来传递来的

**lesson 263 调用函数传递实参的引用**

```python
def test(num):
    print("函数内部 %d 对应的内存地址是 %d" %(num, id(num)))


# 定义一个数字变量
a = 10

# 数据的地址本质上是一个数字
print(" a 变量的内存地址是 %d" % id(a))

# 调用 test 函数，本质上传递的是实参保存数据的引用，而不是实参保存的数据
test(a)


```

**output：**

```
 a 变量的内存地址是 4448069024
函数内部 10 对应的内存地址是 4448069024
```
**lesson 264 函数返回值传递引用**

```python
def test(num):
    print("函数内部 %d 对应的内存地址是 %d" %(num, id(num)))

    result = "hello"

    print("函数要返回的数据的内存地址是：%d" % id(result))

    # 返回字符串变量
    return result
# 定义一个数字变量
a = 10

# 数据的地址本质上是一个数字
print(" a 变量的内存地址是 %d" % id(a))

# 调用 test 函数，本质上传递的是实参保存数据的引用，而不是实参保存的数据
# 如果函数有返回，但是没有定义变量接收，程序不会报错，无法获得返回结果

r = test(a)
print("%s 的内存地址是：%d" % (r, id(r)))
```

**output：**

```
 a 变量的内存地址是 4412835232
函数内部 10 对应的内存地址是 4412835232
函数要返回的数据的内存地址是：140265385703152
hello 的内存地址是：140265385703152
```
**lesson 265 可变类型和不可变类型**

### 02. 可变和不可变类型

* **不可变类型**，内存中的数据不允许被修改：
  * 数字类型 `int`, `bool`, `float`, `complex`, `long(2.x)`
  * 字符串 `str`
  * 元组 `tuple`
* **可变类型**，内存中的数据可以被修改
  * 列表 `list`
  * 字典 `dict`

```python
a = 1
a = "hello"
a = [1,2,3]
a = [3,2,1]
```

**lesson 266 列表、字典的修改和赋值**

```python
demo_list = [1, 2, 3]
print("定义列表后的内存地址：%d" % id(demo_list))

demo_list.append(999)
demo_list.pop(0)
demo_list.remove(2)
demo_list[0] = 10

print(demo_list)
print("修改列表后的内存地址：%d" % id(demo_list))

demo_dict = {"name": "小明"}

print("定义字典后的内存地址：%d" % id(demo_dict))

demo_dict["age"] = 18
demo_dict.pop("name")
demo_dict["name"] = "老王"

print(demo_dict)
print("修改字典后的内存地址：%d" % id(demo_dict))
```

**lesson 267 字典的key不能是可变类型**

> *注意：字典的 `key` **只能使用不可变类型的数据***

**注意**

1. **可变类型** 的数据变化，是通过 **方法** 来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**
   * 变量 **不再** 对之前的数据引用
   * 变量 **改为** 对新赋值的数据引用

**哈希(hash)**

* Python 中内置有一个名字叫做 `hash(o)`的函数
  * 接收一个 **不可变类型** 的数据作为 **参数**
  * **返回** 结果是一个 **整数**
* 哈希 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**
  * **相同的内容** 得到 **相同的结果**
  * **不同的内容** 得到 **不同的结果**
* 在 Python 中，设置字典的 **键值对** 时，会首先对 `key` 进行 hash 以决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**
  * 键值对的 `key` 必须是不可变类型
  * 键值对的 `value` 可以时任意类型


**lesson 268 局部变量和全局变量1**

### 03. 局部变量和全局变量

* **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
* **全局变量** 是在 **函数外部定义** 的变量，（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> *提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护！*

#### 3.1 局部变量

* **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
* 函数执行结束后，**函数内部的局部变量，会被系统回收**
* 不同的函数，可以定义相同的名字的局部变量，但是各用各的，不会产生影响

**局部变量的作用**

* 在函数内部使用，**临时** 保存 **函数内部需要使用的数据**

```python
def demo1():
    # 定义一个局部变量
    num = 10
    print("在demo1中定义的变量是 %d" % num)


def demo2():
    # print("%d" % num)
    pass

demo1()
demo2()
```

**lesson 269 局部变量和全局变量2**

**局部变量的生命周期**

* 所谓 **生命周期** 就是变量从 **被创建** 到 **被系统回收** 的过程
* **局部变量** 在 **函数执行时** 才会被创建
* **函数执行结束后** 局部变量 **被系统回收**
* **局部变量在生命周期** 内，可以用来存储 **函数内部临时使用到的数据**



**lesson 270 局部变量和全局变量3**



**lesson 271 局部变量和全局变量4**

* 不同的函数，可以定义相同的名字的局部变量

**lesson 272 局部变量和全局变量5**

#### 3.2 全局变量

* **全局变量** 是在 **函数外部定义 **的变量，所有函数内部都可以使用这个变量

```python
num = 10


def demo1():
    print("demo1 ==> %d" % num)


def demo2():
    print("demo2 ==> %d" % num)


demo1()
demo2()
```

**注意：** 函数执行时，**需要处理变量时** 会：

1. **首先** 查找 **函数内部** 是否存在 **指定名称** **的局部变量，如果有，直接使用**
2. 如果没有，查找 **函数外部** 是否存在 **指定名称** **的全局变量，如果有，直接使用**
3. 如果还没有，程序报错

**lesson 273 局部变量和全局变量6**

pycharm单步调试

**lesson 274 局部变量和全局变量7**

**1) 函数不能直接修改 全局变量的引用**

* **全局变量** 是在 **函数外部定义** 的变量 （没有定义在某一个函数内部），**所有函数**  内部 **都可以使用这个个变量**

> *提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护*

* 在函数内部，可以 **通过全局变量的引用获取对应的数据**
* 但是，**不允许直接修改全局变量的引用** —— 使用赋值语句修改全局变量的值

**lesson 275 局部变量和全局变量8**

单步调试：

```python
num = 10
print(id(num))


def demo1():
    # 只是定义了一个同名的局部变量，不会修改到全局变量
    num = 99
    print("demo1 ==> %d" % num)
    print("demo1 ==> %d" % id(num))
    # 希望修改全局变量的值


def demo2():
    print("demo2 ==> %d" % num)


demo1()
demo2()
```

**lesson 276 局部变量和全局变量9**

**2) 在函数内部修改全局变量的值**

* 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

```python
num = 10
print(id(num))


def demo1():
    # 只是定义了一个同名的局部变量，不会修改到全局变量
    # global 关键字修饰的变量是一个全局变量
    # 在使用赋值语句时，就不会创建局部变量
    global num
    num = 99
    print("demo1 ==> %d" % num)
    print("demo1 ==> %d" % id(num))
    # 希望修改全局变量的值


def demo2():
    print("demo2 ==> %d" % num)


demo1()
demo2()
```

**lesson 277 局部变量和全局变量10**

**3) 全局变量定义的位置**

* 为了保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义在其他函数的上方**

```python
a = 10

def demo():
  print("%d" % a)
  print("%d" % b)
  print("%d" % c)
  
b = 20
demo()
c = 30
```

**注意**

* 由于全局变量 c,是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错

**代码结构示意图如下**

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201118110109972.png" alt="image-20201118110109972" style="zoom:50%;" />





**lesson 278 局部变量和全局变量11**

**4) 全局变量命名的建议**

* 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：
* 全局变量前应增加 `g_`或者 `gl_`的前缀

> *提示：具体的要求格式，各个公司可能有所差异*

**lesson 279 函数参数和返回值的作用**

## 函数高级

**目标**

* 函数参数和返回值的作用
* 函数的返回值 进阶
* 函数的参数 进阶
* 递归函数

### 01. 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **互相组合**，一共有 **4种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201119094528783.png" alt="image-20201119094528783" style="zoom:60%;" />

> 定义函数时，**是否接收参数，或者是否返回结果**，是根据 **实际的功能需求** 来决定的

**lesson 280 利用元组返回多个值**

### 02. 函数的返回值 进阶

* 在程序开发中，有时候，会希望 **一个函数执行结果后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
* **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
* 在函数中使用 `return` 关键字可以返回结果
* 调用函数的一方，可以 **使用变量** 来 **接收** 函数的返回结果

> ***问题：一个函数执行后能否返回多个结果？***

**示例 —— 温度和湿度测量**

* 假设要开发一个函数能够同时返回当前的温度和湿度
* **先完成返回温度** 的功能如下：

```python
def measure():
    """测量温度和湿度"""
    print("测量开始...")
    temp = 39
    print("测量结束...")

    return temp


result = measure()
print(result)
```

* 在利用 **元组** 在返回温度的同时，也能够返回 **湿度**
* 改造如下：

```python
def measure():
    """测量温度和湿度"""
    print("测量开始...")
    temp = 39
    wetness = 50
    print("测量结束...")

    # 返回一个包含多个数据的元组
    return temp, wetness


result = measure()
print(result
```

**lesson 281 接收返回元组函数的方式**

```python
# 元组
result = measure()
print(result)

# 需要单独处理温度或湿度 - 不方便
print(result[0])
print(result[1])

# 使用多个变量一次接收返回结果
gl_temp, gl_wetness = measure()
print("温度:%d" % gl_temp)
print("湿度:%d" % gl_wetness)
```

**lesson 282 交换两个变量的值**

**面试题** —— 交换两个数字

题目要求

1. 有两个整数变量 `a = 6`,`b = 100`
2. 不使用其他变量，**交换两个变量的值**

**解法1 —— 使用其他变量**

```python
# 解法 1 - 使用临时变量
c = b
b = a
a = c
```

**解法2 —— 不使用临时变量**

```python
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b	
```

**解法3 —— Python专有，利用元组**

```python
a,b = b,a	
```

**lesson 283 参数赋值不会影响实参**

###  03. 函数的参数

#### 3.1 不可变和可变参数

> *问题1：在函数内部，针对参数使用 **赋值语句**，会不会影响调用函数时传递的 **实参变量？—— 不会！***

* 无论传递的参数是 **可变** 还是 **不可变**
  * 只要 **针对参数** 使用 **赋值语句**，会在 **函数内部** 修改 **局部变量的引用，不会影响到 外部变量的引用**

```python
def demo(num, num_list):
    print("in function")
    # 函数内部的赋值语句给参数赋值
    num = 99
    num_list = [1, 2, 3]

    print(num)
    print(num_list)
    print("function done")


gl_num = 100
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

**lesson 284 修改可变参数会影响实参**

> 问题2：如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据**

```python
def demo(num_list):
    print("in function:")
    # 使用方法修改列表的内容
    num_list.append(9)
    print(num_list)
    print("function done")


gl_list = [1, 2, 3]
demo(gl_list)
print(gl_list)
```

**lesson 285 调用extend方法**

**面试题 —— +=**

* 在 Python 中，列表变量调用 `+=` 本质上是在执行列表变量的 `expend`方法，不会修改变量的引用

```python
def demo(num, num_list):
    print("in function")
    # num = num + num
    num += num

    # num_list += 等于调用列表的expend方法
    num_list += num_list
    print(num)
    print(num_list)
    print("function done")


gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

**lesson 286 缺省参数的概念和作用**

#### 3.2 缺省参数

* 定义函数时，可以给 **某个参数** 指定一个 **默认值**，具有默认值的参数就叫做 **缺省参数**
* 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
* 函数的缺省参数，**将常见的值设置为参数的缺省值**， 从而 **简化函数的调用**
* 例如：对列表排序的方法

```python
gl_list = [6, 3, 9]

# 默认按升序排列
# 如果需要降序排序，需要执行reverse参数
gl_list.sort(reverse=True)

print(gl_list)
```

**lesson 287 指定函数缺省参数默认值**

##### 指定函数的缺省参数

* 在参数后使用赋值语句，可以指定参数的缺省值

```python
def print_info(name,gender=True):
    """

    :param name: 学生姓名
    :param gender: True：男生，False：女生
    """
    gender_text = "男生"
    if not gender:
        gender_text = "女生"
    print("%s 是 %s" % (name, gender_text))


print_info("小明", True)
```

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！
2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递！

**lesson 288 缺省参数的注意事项**

##### 缺省参数的注意事项

1) 缺省参数的定义位置

* **必须保证 带有默认值的缺省参数 在参数列表的最末尾**
* 所以，以下定义是错误的

```python
def print_info(name, gender=True, title):
	pass
```

**2) 调用带有多个缺省参数的函数**

* 在 **调用函数** 时，如果有 **多个缺省参数**，**需要指定参数名**，这样解释器才能知道参数的对应关系

```python
def print_info(name, title="", gender=True):
    """

    :param title: 职位
    :param name: 学生姓名
    :param gender: True：男生，False：女生
    """
    gender_text = "男生"
    if not gender:
        gender_text = "女生"
    print("[%s] %s 是 %s" % (title, name, gender_text))


print_info("小明")
print_info("小美", gender=False)
```
**lesson 289 多值参数定义及作用**

#### 3.3 多值参数（知道）

##### 定义支持多值参数的函数

* 有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用 **多值参数**
* Python 中有 **两种** 多值参数：
  * 参数名前增加**一个** `*` 可以接收 **元组**
  * 参数名前增加**两个** `*` 可以接收 **字典**
* 一般在给多值参数命名时，**习惯**使用以下两个名字
  * `*args` **——** 存放 **元组** 参数，前面有一个 `*`
  * `**kwargs`  **——** 存放 **列表** 参数，前面有一个 `**`
* `args` 是 `arguments`的缩写，有变量的含义
* `kw` 是 keyword 的缩写，`kwargs` 可以记忆 **键值对参数**

```python
def demo(num, *args, **kwargs):
    print(num)
    print(args)
    print(kwargs)


demo(1, 2, 3, name="xiaoming", age=18)
```

> 提示：**多值参数** 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，**有利于我们能够读懂大牛的代码**

**lesson 290 数字累加案例演练**

##### 多值参数案例 —— 计算任意多个数字的和

**需求**

1. 定义一个函数 `sum_numbers` ,可以接收的 **任意多个整数**
2. 功能要求：将传递的 **所有数字累加** 并且返回累加结果

```python
def sum_numbers(*args):
    num = 0
    for i in args:
        num += i
    return num


result = sum_numbers(1, 2, 3, 4, 5)
print("result : %d" % result)
```

**lesson 291 元组和字典的拆包**

##### 元组和字典的拆包（知道）

* 在调用带有多值参数的函数时，如果希望：
  * 将一个 **元组变量**，直接传递给 `args`
  * 将一个 **字典变量**，直接传递给`kwargs`
* 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
  * 在 **元组变量前**，增加 **一个** `*`
  * 在 **字典变量前**，增加 **两个** `*`

```python
def demo(*args, **kwargs):
    print(args)
    print(kwargs)


# 元组变量或者字典变量直接传递给函数时
gl_nums = (1, 2, 3)
gl_dict = {"name": "小明", "age": 18}

# 拆包语法，简化传递
demo(*gl_nums, **gl_dict)
```

**lesson 292 递归特点及基本代码演练**

### 04. 函数的递归

> 函数调用自身的 **编程技巧** 称为递归

#### 4.1 递归函数的特点

**特点**

* **一个函数 内部 调用自己**
  * 函数内部可以调用其它函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行
   * **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环！**

示例代码

```python
def sum_number(num):
    print(num)
    # 递归的出口，但参数满足某个条件时，不再执行函数
    if num == 1:
        return
    # 自己调用自己
    sum_number(num - 1)

 
sum_number(3)
```

**lesson 293 递归演练代码执行流程图**

<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201120105822157.png" alt="image-20201120105822157" style="zoom:60%;" />



**lesson 294 递归实现数字累加**

#### 4.2 递归案例 —— 计算数字累加

**需求**

1. 定义一个函数 `sum_numbers`
2. 能够接收一个 `num` 的整数参数
3. 计算 `1+2+...num`的结果

```python
# 1. 定义一个函数 sum_numbers
def sum_number(num):
    # 出口
    if num == 1:
        return 1
    # 2. 数字的累加 num + (1...num-1)
    # 假设sum_numbers 能够正确处理 1...num-1
    temp = sum_number(num - 1)
    
    # 函数内部的核心算法是 两个数字的相加
    return temp + num


result = sum_number(100)
print("result: %d" % result)
```

**lesson 295 数字累加的执行流程图**



<img src="/Users/derek/Library/Application Support/typora-user-images/image-20201120111852794.png" alt="image-20201120111852794" style="zoom:80%;" />



> *提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外有用，例如：**遍历整个文件目录的结构***

